/// \file AnalysisTools.h
/*
 *
 * AnalysisTools.h header template automatically generated by a class generator
 * Creation date : ven. avr. 15 2016
 *
 * This file is part of DQMSHCAL libraries.
 *
 * DQMSHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQMSHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQMSHCAL.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMSDHCAL_ANALYSISTOOLS_H
#define DQMSDHCAL_ANALYSISTOOLS_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/DQMLogging.h"
#include "dqm4hep/DQMElectronicsMapping.h"

// -- lcio headers
#include "EVENT/LCEvent.h"
#include "EVENT/LCCollection.h"
#include "EVENT/CalorimeterHit.h"

// -- calo software headers
#include "CaloObject/Asic.h"
#include "CaloObject/CaloHit.h"
#include "Algorithm/Tracking.h"
#include "Algorithm/Cluster.h"
#include "Algorithm/ClusteringHelper.h"
#include "Algorithm/InteractionFinder.h"
#include "Algorithm/Efficiency.h"
#include "Algorithm/AsicKeyFinder.h"

namespace dqm4hep { class TiXmlHandle; }
namespace caloobject { class CaloTrack; class CaloHit; class CaloCluster; }

namespace dqm_sdhcal
{

/**
 * EventHelper Class
 */
class  EventHelper
{
public:

	struct EventParameters
	{
		dqm4hep::dqm_uint                        eventIntegratedTime;
		dqm4hep::dqm_uint                        spillIntegratedTime;
		dqm4hep::dqm_uint                        lastSpillIntegratedTime;
		dqm4hep::dqm_uint                        totalIntegratedTime;
		dqm4hep::dqm_uint                        timeTrigger;
		dqm4hep::dqm_uint                        timeSpill;
		dqm4hep::dqm_uint                        timeLastTrigger;
		dqm4hep::dqm_uint                        timeLastSpill;
		dqm4hep::dqm_uint                  	 nTriggerInSpill;
		dqm4hep::dqm_uint                  	 nTriggerLastSpill;
		dqm4hep::dqm_uint                  	 nTriggerProcessed;
		dqm4hep::dqm_bool                  	 newSpill;
		dqm4hep::dqm_bool                  	 newTrigger;

	  void dumpParameters(){
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "eventIntegratedTime : " << eventIntegratedTime);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "spillIntegratedTime : " << spillIntegratedTime);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "lastSpillIntegratedTime : " << lastSpillIntegratedTime);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "totalIntegratedTime : " << totalIntegratedTime);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "timeTrigger : " << timeTrigger);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "timeSpill : " << timeSpill);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "timeLastTrigger : " << timeLastTrigger);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "timeLastSpill : " << timeLastSpill);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "nTriggerInSpill : " << nTriggerInSpill);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "nTriggerLastSpill : " << nTriggerLastSpill);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "nTriggerProcessed : " << nTriggerProcessed);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "newSpill : " << newSpill);
	    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "newTrigger : " << newTrigger);
	  }
	};

public:
	/** Constructor
	 */
	EventHelper();

	/** Destructor
	 */
	virtual ~EventHelper();


	inline unsigned int getDifId(int cellID)      { return cellID & 0xFF; }
	inline unsigned int getAsicId(int cellID)     { return (cellID & 0xFF00) >> 8; }
	inline unsigned int getChannelId(int cellID)  { return (cellID & 0x3F0000) >> 16; }

	inline const float getDAQ_BC_Period() {return m_DAQ_BC_Period;}
	inline const int getSpillTimeCut() {return m_newSpillTimeCut;}

	// inline EventParameters getEventParameters() {return m_evtParameters;}

	unsigned int getThreshold( const EVENT::CalorimeterHit *pInputCaloHit )
	{
		int shift;
		const float amplitude( pInputCaloHit->getEnergy());

		if ( amplitude > 2.5 )
			shift = 0;         // 3rd threshold
		else if ( amplitude > 1.5 )
			shift = -1;        // 2nd threshold
		else
			shift = +1;        // 1rst Threshold

		return static_cast<unsigned int>(amplitude) + shift;
	}

	/** Read settings from the xml handle
	 */
	dqm4hep::StatusCode readSettings(const dqm4hep::TiXmlHandle xmlHandle);

	/**
	 * decode lcio parameters from the triggerEvent
	 */
	dqm4hep::StatusCode decodeEventParameter(EVENT::LCCollection *pLCCollection, EventParameters &m_evtParameters);

	/**
	 * find trigger information in the triggerEvent
	 */
	dqm4hep::StatusCode findTrigger(EVENT::LCCollection * pLCCollection, EventParameters &m_evtParameters);
	
private:
	EventParameters					m_evtParameters;
	float										m_DAQ_BC_Period;
	float										m_newSpillTimeCut;
	unsigned long long			m_shiftBCID;
	unsigned int 						m_nStartLayerShift;
	std::string 						m_cellIDDecoderString;
	std::string 						m_moduleLogStr;
	
  dqm4hep::DQMElectronicsMapping            *m_pElectronicsMapping;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** EventClassifier class
 */
class EventClassifier
{
public:
	/** EventType enumerator
	 */
	enum EventType
	{
		UNDEFINED_EVENT,
		SQUARE_NOISE_EVENT,
		GROUNDING_NOISE_EVENT,
		BEAM_MUON_EVENT,
		COSMIC_MUON_EVENT,
		SHOWER_EVENT,           // global tag if not one of the following tags
		NEUTRAL_EM_SHOWER_EVENT,
		CHARGED_EM_SHOWER_EVENT,
		NEUTRAL_HAD_SHOWER_EVENT,
		CHARGED_HAD_SHOWER_EVENT
	};

public:
	/** Constructor
	 */
	EventClassifier();

	/** Destructor
	 */
	virtual ~EventClassifier();

	/** Process the event and classify it
	 */
	virtual dqm4hep::StatusCode processEvent(EVENT::LCEvent *pLCEvent) = 0;

	/** Whether the event has been classified as a noisy one.
	 *  Could be one of the following event type
	 *   - SQUARE_NOISE_EVENT
	 *	 - GROUNDING_NOISE_EVENT
	 *  May be overloaded by user to define more event types
	 */
	virtual bool isNoisyEvent() const;

	/** Whether the event has been classified as a physics one.
	 *  Could be one of the following event type
	 *   - BEAM_MUON_EVENT
	 *	 - COSMIC_MUON_EVENT
	 *	 - SHOWER_EVENT
	 *	 - NEUTRAL_EM_SHOWER_EVENT
	 *	 - CHARGED_EM_SHOWER_EVENT
	 *	 - NEUTRAL_HAD_SHOWER_EVENT
	 *	 - CHARGED_HAD_SHOWER_EVENT
	 *  May be overloaded by user to define more event types
	 */
	virtual bool isPhysicsEvent() const;

	/** Whether the event has been classified as a muon one.
	 *  Could be one of the following event type
	 *   - BEAM_MUON_EVENT
	 *	 - COSMIC_MUON_EVENT
	 *  May be overloaded by user to define more event types
	 */
	virtual bool isMuonEvent() const;

	/** Whether the event has been classified as a shower one.
	 *  Could be one of the following event type
	 *	 - SHOWER_EVENT
	 *	 - NEUTRAL_EM_SHOWER_EVENT
	 *	 - CHARGED_EM_SHOWER_EVENT
	 *	 - NEUTRAL_HAD_SHOWER_EVENT
	 *	 - CHARGED_HAD_SHOWER_EVENT
	 *  May be overloaded by user to define more event types
	 */
	virtual bool isShowerEvent() const;

	/** Whether the event has been classified as undefined.
	 */
	virtual bool isUndefined() const;

	/** Read settings from the xml handle
	 */
	virtual dqm4hep::StatusCode readSettings(const dqm4hep::TiXmlHandle xmlHandle) = 0;

	/** Get the event type after event classification
	 *  May be set in processEvent(evt) by subclasses
	 *  using setEventType(type, level)
	 */
	EventType getEventType() const;

	/** Get the confidence level of the event classification
	 *  Range and meaning is user defined
	 */
	unsigned int getConfidenceLevel() const;

protected:
	/** Set the event type and confidence level of the current event.
	 *  May be called from processEvent(evt) by subclasses
	 */
	void setEventType(EventType type, unsigned int confidenceLevel);

private:
	unsigned int                     m_confidenceLevel;
	EventType                        m_eventType;
	std::string                      m_moduleLogStr;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

/** SDHCALEventClassifier class
 */
class SDHCALEventClassifier : public EventClassifier
{
	typedef std::vector<caloobject::CaloHit *> CaloHitList;
	typedef std::map<unsigned int, CaloHitList > CaloHitMap;
	typedef std::vector<caloobject::CaloCluster *> CaloClusterList;
	typedef std::vector<caloobject::CaloTrack *> CaloTrackList;
public:
	/** Constructor
	 */
	SDHCALEventClassifier();

	/** Process the event and classify it
	 */
	dqm4hep::StatusCode processEvent(EVENT::LCEvent *pLCEvent);

	/** Read settings from the xml handle
	 */
	dqm4hep::StatusCode readSettings(const dqm4hep::TiXmlHandle xmlHandle);

	/** Run a complete tracking on the event
	 */
	dqm4hep::StatusCode runTracking(EVENT::LCEvent *pLCEvent, caloobject::CaloTrack *&pTrack);

private:
	/** Clear the event contents
	 */
	void clearEventContents(CaloHitList &hits, CaloClusterList &clusters, CaloTrackList &tracks);

	/** Get the shower starting layer
	 */
	int getStartingLayer(const CaloHitMap &caloHitMap);

	/** Whether the shower is a neutral hadron
	 */
	bool isNeutralHadron(const CaloHitMap &caloHitMap);

private:
	// algorithms
	algorithm::Cluster                           m_clusteringAlgorithm;
	algorithm::ClusteringHelper                  m_clusteringHelper;
	algorithm::Tracking                          m_trackingAlgorithm;
	algorithm::InteractionFinder                 m_interactionFinderAlgorithm;

	// algorithm parameters
	algorithm::clusterParameterSetting           m_clusteringSettings;
	algorithm::ClusteringHelperParameterSetting  m_clusteringHelperSettings;
	algorithm::TrackingParameterSetting          m_trackingSettings;
	algorithm::InteractionFinderParameterSetting m_interactionFinderSettings;

	// input parameters
	std::string                                  m_inputCollectionName;
	std::string                                  m_cellIDDecoderString;
	unsigned int                                 m_nActiveLayers;

	// noise cut settings
	unsigned int                                 m_noiseMinTouchedLayers;
	unsigned int                                 m_noiseMinNHit;

	// muon tracking cut settings
	float                                        m_muonMaxCosmicCosTheta;

	// shower cut settings
	unsigned int                                 m_neutralNFirstLayers;
	unsigned int                                 m_neutralMaxNHitPerLayer;
	unsigned int                                 m_startingLayerCogRegion;
	unsigned int                                 m_startingLayerNNextLayers;
	unsigned int                                 m_startingLayerCounter;
	float                                        m_showerMinTransverseRatio;
	float                                        m_showerMinNHitOverNTouchedLayers;
	unsigned int                                 m_electronMaxNTouchedLayers;
	unsigned int                                 m_electronMaxStartingLayer;
	
	std::string 																 m_moduleLogStr;
};

}

#endif  //  DQMSDHCAL_ANALYSISTOOLS_H
