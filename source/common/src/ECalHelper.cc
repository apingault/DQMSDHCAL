  /// \file ECalHelper.cc
/*
 *
 * ECalHelper.cc source template automatically generated by a class generator
 * Creation date : sam. juin 11 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqmsdhcal headers
#include "ECalHelper.h"

// -- root headers
#include "TH2.h"
#include "TFile.h"

namespace dqm_sdhcal
{

ECalHelper::ECalHelper()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

ECalHelper::~ECalHelper()
{
	// clear TH2 maps
	for(auto iter = m_slabPedestalMap.begin(), endIter = m_slabPedestalMap.end() ; endIter != iter ; ++iter)
	{
		for(auto iter2 = iter->second.begin(), endIter2 = iter->second.end() ; endIter2 != iter2 ; ++iter2)
		{
			delete iter2->second;
		}
	}
}

//-------------------------------------------------------------------------------------------------

unsigned int ECalHelper::getNLayers() const
{
	return m_layerToHwLayerMap.size();
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getLayer(int hwLayer, unsigned int &layer) const
{
	auto iter = m_hwLayerToLayerMap.find(hwLayer);

	if(m_hwLayerToLayerMap.end() == iter)
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	layer = iter->second;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getHwLayer(unsigned int layer, int &hwLayer) const
{
	auto iter = m_layerToHwLayerMap.find(layer);

	if(m_layerToHwLayerMap.end() == iter)
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	hwLayer = iter->second;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getSlab(unsigned int layer, unsigned int &slab) const
{
	int hwLayer(0);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->getHwLayer(layer, hwLayer));

	auto iter = m_hwLayerToSlabMap.find(hwLayer);

	if(m_hwLayerToSlabMap.end() == iter)
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	slab = iter->second;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getPedestal(unsigned int layer, unsigned int asic, unsigned int channel, unsigned int column, int &pedestal) const
{
	unsigned int slab(0);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->getSlab(layer, slab));

	auto iter = m_slabPedestalMap.find(slab);

	if(m_slabPedestalMap.end() == iter)
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	auto pedestalIter = iter->second.find(column);

	if(pedestalIter == iter->second.end())
		return dqm4hep::STATUS_CODE_NOT_FOUND;

	TH2 *pPedestalHistogram = pedestalIter->second;

	Int_t bin = pPedestalHistogram->FindFixBin(static_cast<double>(channel)+0.5, static_cast<double>(asic)+0.5);

	if(bin < 0)
		return dqm4hep::STATUS_CODE_FAILURE;

	Double_t pedestalValue = pPedestalHistogram->GetBinContent(bin);
	pedestal = round(pedestalValue + m_pedestalShift);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getCorrectedADCCount(unsigned int layer, unsigned int asic, unsigned int channel,
		unsigned int column, int adcCount, int &correctedAdcCount) const
{
	int pedestalValue(0);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->getPedestal(layer, asic, channel, column, adcCount));

	correctedAdcCount = adcCount - pedestalValue;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::getCalibratedEnergy(unsigned int layer, unsigned int asic, unsigned int channel,
		unsigned int column, int correctedAdcCount, float &calibratedEnergy) const
{
	int pedestalValue(0);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->getPedestal(layer, asic, channel, column, correctedAdcCount));

	const float adcToMip(correctedAdcCount / m_mipCalibrationFactor);
	calibratedEnergy = adcToMip * m_mipEquivalentEnergy;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalHelper::readSettings(const dqm4hep::TiXmlHandle &xmlHandle)
{
	dqm4hep::IntVector hardwareLayerMapping;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"HardwareLayerMapping", hardwareLayerMapping));

	if(hardwareLayerMapping.size() % 2 != 0 || hardwareLayerMapping.empty())
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	for(unsigned int i=0 ; i<hardwareLayerMapping.size()-1 ; i+=2)
	{
		int hwLayer(hardwareLayerMapping.at(i));
		unsigned int layer(hardwareLayerMapping.at(i+1));

		m_layerToHwLayerMap[layer] = hwLayer;
		m_hwLayerToLayerMap[hwLayer] = layer;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Read : layer " << layer << " hw layer " << hwLayer );
	}

	dqm4hep::IntVector slabMapping;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"SlabMapping", slabMapping));

	if(slabMapping.size() % 2 != 0 || slabMapping.empty())
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	for(unsigned int i=0 ; i<slabMapping.size()-1 ; i+=2)
	{
		int hwLayer(slabMapping.at(i));
		unsigned int slab(slabMapping.at(i+1));

		m_hwLayerToSlabMap[hwLayer] = slab;
		m_slabToHwLayerMap[slab] = hwLayer;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Read : hw layer " << hwLayer << " slab " << slab );
	}

	m_nColumns = 15;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NColumns", m_nColumns));

	m_pedestalShift = 250;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"PedestalShift", m_pedestalShift));

	std::string pedestalRootFileName;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"PedestalRootFileName", pedestalRootFileName));

	for(auto iter = m_slabToHwLayerMap.begin(), endIter = m_slabToHwLayerMap.end() ; endIter != iter ; ++iter)
	{
		const unsigned int slab(iter->first);
		std::string pedestalFileName = pedestalRootFileName;

		dqm4hep::DQM4HEP::replace(pedestalFileName, "id", slab);

		TFile *pFile = TFile::Open(pedestalFileName.c_str(), "READ");

		if(!pFile)
		{
			LOG4CXX_WARN(dqm4hep::dqmMainLogger, "Couldn't open pedestal data file or slab '" << slab << "' !");
			continue;
		}

		TDirectory *pDirectory = pFile->GetDirectory("maps");

		if(!pDirectory)
		  {
		    LOG4CXX_ERROR(dqm4hep::dqmMainLogger, "Couldn't find 'maps' directory for slab '" << slab << "' !");

		    pFile->Close();
		    delete pFile;

		    continue;
		  }

		ColumnToPedestalMap columnToPedestalMap;

		for(unsigned int c=0 ; c<m_nColumns ; c++)
		{
			std::stringstream pedestalMapName;
			pedestalMapName << "h_img" << c << "_filtred";

			TH2 *pPedestalHistogram = (TH2 *)pDirectory->Get(pedestalMapName.str().c_str());

			if(!pPedestalHistogram)
			{
				LOG4CXX_ERROR(dqm4hep::dqmMainLogger, "Couldn't find pedestal histogram for slab '" << slab << "' and column '" << c << "' !");

				pFile->Close();
				delete pFile;

				return dqm4hep::STATUS_CODE_NOT_FOUND;
			}

			columnToPedestalMap[c] = (TH2*) pPedestalHistogram->Clone();
		}

		m_slabPedestalMap.insert(SlabPedestalMap::value_type(slab, columnToPedestalMap));

		pFile->Close();
		delete pFile;
	}

	m_correctedPedestalCut = 20;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CorrectedPedestalCut", m_correctedPedestalCut));

	m_mipCalibrationFactor = 60;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"MipCalibrationFactor", m_mipCalibrationFactor, [] (unsigned int f) {return f>0;} ));

	m_mipEquivalentEnergy = 0.0012715; // unit GeV
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"MipEquivalentEnergy", m_mipEquivalentEnergy, [] (float e) {return e>0;} ));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

