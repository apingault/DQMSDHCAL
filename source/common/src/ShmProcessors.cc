  /// \file ShmProcessors.cc
/*
 *
 * ShmProcessors.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 14 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ShmProcessors.h"
#include "DIF.h"
#include "DIFUnpacker.h"

// -- dqm4hep headers
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMRun.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMCoreTool.h"

// -- lcio headers
#include "EVENT/LCIO.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCParameters.h"
#include "IMPL/LCEventImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCFlagImpl.h"
#include "IMPL/LCRunHeaderImpl.h"
#include "IMPL/RawCalorimeterHitImpl.h"
#include "IMPL/CalorimeterHitImpl.h"
#include "UTIL/CellIDEncoder.h"
#include "UTIL/CellIDDecoder.h"
#include "IO/LCWriter.h"
#include "IOIMPL/LCFactory.h"

// -- std headers
#include <bitset>

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( EventInfoShmProcessor , "EventInfoShmProcessor" )
DQM_PLUGIN_DECL( SDHCALShmProcessor    , "SDHCALShmProcessor"    )
DQM_PLUGIN_DECL( CherenkovShmProcessor , "CherenkovShmProcessor" )
DQM_PLUGIN_DECL( SiWECalShmProcessor   , "SiWECalShmProcessor"   )
DQM_PLUGIN_DECL( FileWriterShmProcessor, "FileWriterShmProcessor")

EventInfoShmProcessor::EventInfoShmProcessor() :
		m_eventNumber(0),
		m_runNumber(0),
		m_moduleLogStr("[EventInfoShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

EventInfoShmProcessor::~EventInfoShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	m_runNumber = pRun->getRunNumber();
	m_detectorName = pRun->getDetectorName();
	m_eventNumber = 0;

	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== Starting new run " << m_runNumber << " , detector name : " << m_detectorName << " ====" );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== Ending run " << pRun->getRunNumber() << " , detector name : " << m_detectorName << " ====" );
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - ===== N processed events : " << m_eventNumber );

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	pLCEvent->setEventNumber( m_eventNumber );
	pLCEvent->setRunNumber( m_runNumber );
	pLCEvent->setDetectorName( m_detectorName );

	// set event creation time is parameters
	time_t currentTime = std::chrono::system_clock::to_time_t(dqm4hep::DQMCoreTool::now());
	pLCEvent->parameters().setValue( m_creationTimeParameterName , static_cast<int>(currentTime) );
	pLCEvent->setTimeStamp(currentTime);

	m_eventNumber++;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode EventInfoShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_creationTimeParameterName = "CREATION_TIME";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CreationTimeParameterName", m_creationTimeParameterName));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


DIFPtr *SDHCALDifHelper::createDIFPtr(levbdim::buffer *pBuffer, unsigned int xdaqShift)
{
	uint32_t idstart = DIFUnpacker::getStartOfDIF((unsigned char*) pBuffer->ptr(), pBuffer->size(), xdaqShift);
	DIFPtr *pDifPtr = new DIFPtr( (unsigned char*) &pBuffer->ptr()[idstart] , pBuffer->size() - idstart + 1 );
	return pDifPtr;
}

//-------------------------------------------------------------------------------------------------

bool SDHCALDifHelper::isEmptyPad(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	return ( ! ( pDifPtr->getFrameLevel(frame, channel, 0) || pDifPtr->getFrameLevel(frame, channel, 1) ) );
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::fillDifTriggerInfo(DIFPtr *pDifPtr, dqm4hep::IntVector &trigger)
{
	trigger.push_back(pDifPtr->getDTC());
	trigger.push_back(pDifPtr->getGTC());
	trigger.push_back(pDifPtr->getBCID());
	trigger.push_back(pDifPtr->getAbsoluteBCID()&0xFFFFFF);
	trigger.push_back((pDifPtr->getAbsoluteBCID()/(0xFFFFFF+1))&0xFFFFFF);
	trigger.push_back(pDifPtr->getTASU1());
	trigger.push_back(pDifPtr->getTASU2());
	trigger.push_back(pDifPtr->getTDIF());
}

//-------------------------------------------------------------------------------------------------

void SDHCALDifHelper::setCaloHitLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_LONG );  // raw calorimeter data -> format long
	lcFlag.setBit( bitinfo.RCHBIT_BARREL ); // barrel
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // timestamp
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::SDHCALShmProcessor():
		m_skipFullAsics(0),
		m_dropFirstRU(0),
		m_encodeDifAsicChannel(0),
		m_xdaqShift(0),
		m_detectorId(0),
		m_noiseLimit(0),
		m_amplitudeBitRotation(0),
		m_pElectronicsMapping(NULL),
		m_moduleLogStr("[SDHCALShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SDHCALShmProcessor::~SDHCALShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " [SDHCALshmProcessor] - startOfRun.." );
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}
	if (key%100==0)
	  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - newLCEvent...with key '"<<key<<"' and creationTime: '"<<pLCEvent->getTimeStamp()<<"'" );

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	bool isFirstRU = true;
	bool reachedNoiseLimit = false;
	unsigned int nDifs(0);

	// loop over dif raw buffers and convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		if( reachedNoiseLimit )
			break;

		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
		  {
			continue;
		}

		if( isFirstRU && m_dropFirstRU )
		{
			isFirstRU = false;
			continue;
		}

		// create dif pointer to extract info
		try{
		  DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);
		  
		// check for dif mask
		unsigned int difId = pDifPtr->getID();
		// Change timeStamp to the trigger timeStamp
		pLCEvent->setTimeStamp(pDifPtr->getBCID());

		if( m_difMaskList.find(difId) != m_difMaskList.end() )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			if( reachedNoiseLimit )
				break;

			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				EVENT::CalorimeterHit *pCaloHit = this->createCalorimeterHit(cellIDEncoder, pDifPtr, f, ch);

				if(0 == pCaloHit)
					continue;

				pOutputCollection->addElement(pCaloHit);

				if (pOutputCollection->getNumberOfElements() > m_noiseLimit)
				{
					reachedNoiseLimit = true;
					break;
				}
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);
		++nDifs;

		delete pDifPtr;
		}
		catch(...)
		  {std::cout<<"Exception in difptr"<<std::endl;}
	}

	std::vector<int> difMaskList(m_difMaskList.begin(), m_difMaskList.end());

	pOutputCollection->parameters().setValue("NDifs", static_cast<int>(nDifs));
	pOutputCollection->parameters().setValue("NoiseLimitsReached", static_cast<int>(reachedNoiseLimit));
	pOutputCollection->parameters().setValue("DropFirstRU", static_cast<int>(m_dropFirstRU));
	pOutputCollection->parameters().setValue("NoiseLimit", static_cast<int>(m_noiseLimit));
	pOutputCollection->parameters().setValue("XdaqShift", static_cast<int>(m_xdaqShift));
	pOutputCollection->parameters().setValue("DetectorId", static_cast<int>(m_detectorId));
	pOutputCollection->parameters().setValues("DifMask", difMaskList);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

IMPL::CalorimeterHitImpl *SDHCALShmProcessor::createCalorimeterHit(UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> &cellIDEncoder, DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	// dif - asic - channel
	unsigned short difId        = pDifPtr->getID();
	unsigned short asicId       = pDifPtr->getFrameAsicHeader(frame);
	unsigned long int channelId = channel;

	// time stamp  - unit = bin of 200 ns from trigger
	const float timeStamp  = static_cast<float>(pDifPtr->getFrameTimeToTrigger(frame));
	
	if ( timeStamp - pDifPtr->getBCID() > 0) 
	{
 		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Funny hitTimestamp : " << (unsigned long int)(pDifPtr->getFrameTimeToTrigger(frame)) << "\t BCID : " << pDifPtr->getBCID() << "\t ABCID : " << (pDifPtr->getAbsoluteBCID()&0xFFFFFF));
	}

	// get the SDHCAL threshold
	std::bitset<3> threshold;
	threshold[0] = pDifPtr->getFrameLevel(frame, channel, 0);
	threshold[1] = pDifPtr->getFrameLevel(frame, channel, 1);
	threshold[2] = false;

	float shift;
	const float amplitude( static_cast<float>( threshold.to_ulong() & m_amplitudeBitRotation ) );

  if( amplitude > 2.5 )
		shift = 0;         // 3rd threshold
  else if( amplitude > 1.5 )
		shift = -1;        // 2nd threshold
	else
		shift = +1;        // 1rst Threshold

  const float energy(amplitude + shift);

  // perform conversion to cell ids and absolute position
  dqm4hep::DQMElectronicsMapping::Electronics electronics;
  electronics.m_difId = difId;
  electronics.m_asicId = asicId;
  electronics.m_channelId = channelId;

	dqm4hep::DQMCartesianVector position(0.f, 0.f, 0.f);
	dqm4hep::DQMElectronicsMapping::Cell cell;

	try
	{
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicsToPosition(electronics, position));
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->electronicstoCell(electronics, cell));
	}
	catch(dqm4hep::StatusCodeException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Couldn't decode hit using electronics mapping : " << exception.toString() );
		return 0;
	}
	catch(...)
	{
		LOG4CXX_FATAL( dqm4hep::dqmMainLogger, m_moduleLogStr << " - Caught Unknown exception " );
		return 0;
	}

	try
	{
		// set the cell id
		cellIDEncoder[ m_ijkEncoding.at(0) ] = cell.m_iCell;
		cellIDEncoder[ m_ijkEncoding.at(1) ] = cell.m_jCell;
		cellIDEncoder[ m_ijkEncoding.at(2) ] = cell.m_layer;

	    if( m_encodeDifAsicChannel )
		{
			cellIDEncoder[ m_difAsicChannelEncoding.at(0) ] = electronics.m_difId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(1) ] = electronics.m_asicId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(2) ] = electronics.m_channelId;
		}
	}
	catch(EVENT::Exception &e)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger, m_moduleLogStr << " - While encoding hits, EVENT::Exception caught : " << e.what() );
		return 0;
	}

    // set the position
	float positionArray [3] = { position.getX() , position.getY() , position.getZ() };

	// create the calorimeter hit
	IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();
	pCaloHit->setPosition( positionArray );
	pCaloHit->setEnergy(energy);
	cellIDEncoder.setCellID( pCaloHit );
	pCaloHit->setTime(timeStamp);

	return pCaloHit;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SDHCALShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	dqm4hep::TiXmlElement *pMappingXmlElement = xmlHandle.FirstChild("electronicsMapping").Element();

	if( ! pMappingXmlElement )
  {
    LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " -  Couldn't find xml element electronicsMapping !" );
		return dqm4hep::STATUS_CODE_NOT_FOUND;
  }

	std::string plugin;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::getAttribute(pMappingXmlElement, "plugin", plugin));

	// query electronics mapping plugin instance and configure
	m_pElectronicsMapping = dqm4hep::DQMPluginManager::instance()->createPluginClass<dqm4hep::DQMElectronicsMapping>(plugin);

	dqm4hep::TiXmlHandle mappingHandle(pMappingXmlElement);
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_pElectronicsMapping->readSettings(mappingHandle));

	m_amplitudeBitRotation = 3;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"AmplitudeBitRotation", m_amplitudeBitRotation));

	m_encodeDifAsicChannel = true;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"EncodeDifAsicChannel", m_encodeDifAsicChannel));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"IJKEncoding", m_ijkEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	m_cellIDEncoderString = "M:3,S-1:3,I:9,J:9,K-1:6";

	if( m_encodeDifAsicChannel )
	{
		m_cellIDEncoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
				"DifAsicChannelEncoding", m_difAsicChannelEncoding, [&] (const dqm4hep::StringVector &vec) {
			return vec.size() == 3;
		}));
	}

	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDEncoderString", m_cellIDEncoderString));

	m_skipFullAsics = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"SkipFullAsics", m_skipFullAsics));

	m_dropFirstRU = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DropFirstRU", m_dropFirstRU));

	m_noiseLimit = 100000;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NoiseLimit", m_noiseLimit));

	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "DHCALRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	dqm4hep::UIntVector difMaskList;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"DifMaskList", difMaskList));

	m_difMaskList.insert( difMaskList.begin(), difMaskList.end() );
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - SDCALshMProcessor - End of readSettings" );
	
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::CherenkovShmProcessor() :
		m_detectorId(0),
		m_xdaqShift(0),
		m_cherenkovDifId(0),
		m_amplitudeBitRotation(0),
		m_cherenkovTimeShift(0),
		m_moduleLogStr("[CherenkovShmProcessor]")
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

CherenkovShmProcessor::~CherenkovShmProcessor()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::startOfRun(dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::endOfRun(const dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	LOG4CXX_INFO( dqm4hep::dqmMainLogger, "Cherenkov : Starting new event "<< key << " !" );

	IMPL::LCFlagImpl chFlag(0);
	SDHCALDifHelper::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	int nDifs(0);

	// loop over dif raw buffers
	// find the cherenkov dif
	// convert to raw calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		// create dif pointer to extract info
		DIFPtr *pDifPtr = SDHCALDifHelper::createDIFPtr(pBuffer, m_xdaqShift);

		// check for dif mask
		unsigned int difId = pDifPtr->getID();

		if( m_cherenkovDifId != difId )
		{
			delete pDifPtr;
			continue;
		}

		// loop over frames
		for(uint32_t f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			// loop over hits
			for(uint32_t ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if ( SDHCALDifHelper::isEmptyPad(pDifPtr, f, ch) )
					continue;

				IMPL::CalorimeterHitImpl *pCaloHit = this->createCalorimeterHit(pDifPtr, f, ch);
				float timeStamp = pCaloHit->getTime();

				// apply cherenkov time stamp shift
				if(m_cherenkovTimeShift < 0 && timeStamp < abs(m_cherenkovTimeShift) )
				{
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Reconstructed cherenkov hit with timeStamp = " << timeStamp << ", adding shift of " << m_cherenkovTimeShift << " resulting in negative time stamp !!" );
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Setting time stamp of cherenkov hit to 0 !" );
					pCaloHit->setTime(0.f);
				}
				else
					pCaloHit->setTime( timeStamp + m_cherenkovTimeShift );

				pOutputCollection->addElement(pCaloHit);
			}
		}

		// store trigger info in collection
		dqm4hep::IntVector trigger;
		std::stringstream triggerParameterName;

		SDHCALDifHelper::fillDifTriggerInfo(pDifPtr, trigger);
		triggerParameterName << "Cherenkov_DIF" << pDifPtr->getID() << "_Triggers";

		pOutputCollection->parameters().setValues(triggerParameterName.str(), trigger);

		++nDifs;

		delete pDifPtr;
	}

	pOutputCollection->parameters().setValue("XdaqShift", static_cast<int>(m_xdaqShift));
	pOutputCollection->parameters().setValue("DetectorId", static_cast<int>(m_detectorId));
	pOutputCollection->parameters().setValue("CherenkovTimeShift", m_cherenkovTimeShift);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

IMPL::CalorimeterHitImpl *CherenkovShmProcessor::createCalorimeterHit(DIFPtr *pDifPtr, uint32_t frame, uint32_t channel)
{
	std::bitset<6> channelBitSet(channel);
	unsigned long int cellID0(0);
	unsigned long int cellID1(0);
	unsigned long module(0);  // 0 for beam tests

	unsigned short difId        = (((unsigned short) pDifPtr->getID()) & 0xFF);
	unsigned short asicId       = (((unsigned short) pDifPtr->getFrameAsicHeader(frame)<<8)&0xFF00);
	unsigned long int channelId = ((channelBitSet.to_ulong()<<16)&0x3F0000);
	unsigned long int barrelEndcapModule = ((module <<22)&0xFC00000);

	const float timeStamp = static_cast<float>(pDifPtr->getFrameTimeToTrigger(frame));

	cellID0 += (unsigned long int) difId;
	cellID0 += (unsigned long int) asicId;
	cellID0 += (unsigned long int) channelId;
	cellID0 += (unsigned long int) barrelEndcapModule;
	cellID1  = (unsigned long int) pDifPtr->getFrameBCID(frame);

	std::bitset<3> threshold;
	threshold[0] = pDifPtr->getFrameLevel(frame, channel, 0);
	threshold[1] = pDifPtr->getFrameLevel(frame, channel, 1);
	threshold[2] = false; // not synchronized

	float shift;
	const float amplitude( static_cast<float>( threshold.to_ulong() & m_amplitudeBitRotation ) );

    if( amplitude > 2.5 )
		shift = 0;         // 3rd threshold
    else if( amplitude > 1.5 )
		shift = -1;        // 2nd threshold
	else
		shift = +1;        // 1rst Threshold

    const float energy(amplitude + shift);

	float positionArray [3] = {0};

	// create the calorimeter hit
	IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();

	pCaloHit->setCellID0(cellID0);
	pCaloHit->setPosition(positionArray);
	pCaloHit->setEnergy(energy);
	pCaloHit->setTime(timeStamp);

	return pCaloHit;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CherenkovShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_xdaqShift = 24;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"XDaqShift", m_xdaqShift));

	m_detectorId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "CherenkovRawHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	m_cherenkovDifId = 100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovDifId", m_cherenkovDifId));

	m_cherenkovTimeShift = 0;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CherenkovTimeShift", m_cherenkovTimeShift));

	m_amplitudeBitRotation = 3;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"AmplitudeBitRotation", m_amplitudeBitRotation));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SiWECalShmProcessor::SiWECalShmProcessor() :
		m_moduleLogStr("[SiWECalShmProcessor]"),
		m_positionShift(0.f, 0.f, 0.f),
		m_detectorId(0),
		m_adcCountCut(0),
		m_energyMode(0),
		m_negativeAdcCountSuppression(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SiWECalShmProcessor::~SiWECalShmProcessor()
{

}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	LOG4CXX_INFO( dqm4hep::dqmMainLogger, "ECAL : Starting new event "<< key << " !" );

	// Hit collection
	IMPL::LCFlagImpl chFlag(0);
	SiWECalShmProcessor::setCaloHitLCFlag(chFlag);

	IMPL::LCCollectionVec *pOutputCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);
	pLCEvent->addCollection( pOutputCollection, m_outputCollectionName );
	pOutputCollection->setFlag( chFlag.getFlag() );

	UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> cellIDEncoder( m_cellIDEncoderString , pOutputCollection );

	// Raw hit collection
	IMPL::LCFlagImpl chRawFlag(0);
	SiWECalShmProcessor::setRawCaloHitLCFlag(chRawFlag);

	IMPL::LCCollectionVec *pOutputRawCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);
	pLCEvent->addCollection( pOutputRawCollection, m_outputRawCollectionName );
	pOutputRawCollection->setFlag( chRawFlag.getFlag() );

	UTIL::CellIDEncoder<IMPL::RawCalorimeterHitImpl> cellIDRawEncoder( m_cellIDEncoderString , pOutputRawCollection );

	LayerToAsicListMap layerToAsicListMap;

	int sizeofHeader = 20;
	int sizeofHit = 56;

	// loop over dif raw buffers
	// decode hits one by one
	// convert to calorimeter hits
	for(auto bufIter = bufferList.begin(), endBufIter = bufferList.end() ;
			endBufIter != bufIter ; ++bufIter)
	{
		levbdim::buffer *pBuffer = *bufIter;

		// check for correct detector id
		if( pBuffer->detectorId() != m_detectorId )
			continue;

		LOG4CXX_INFO( dqm4hep::dqmMainLogger, "ECAL : New dif =  "<< pBuffer->dataSourceId() << " !" );

		SiWECalRawHit *rawHit = 0;

		unsigned char *pRawBuffer = (unsigned char*) pBuffer->ptr();
		uint32_t bufferSize = pBuffer->size();

		if(0 == bufferSize)
			continue;

		std::cout << "buffer size = " << bufferSize << std::endl;
		
		int32_t invalidBuffer = ( bufferSize - sizeofHeader ) % sizeofHit;

		std::cout << "Remaining bytes = " << invalidBuffer << std::endl;

		if(invalidBuffer)
		{
			LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Invalid SiWECal DIF ptr : Invalid buffer size = " << bufferSize );
			//continue;
		}

		const unsigned int nECalHits(( bufferSize - sizeofHeader ) / sizeofHit);

		unsigned int difId (0);
		unsigned int difSpill(0);

		for(unsigned int i=0 ; i<nECalHits ; ++i)
		{
			rawHit = (SiWECalRawHit *) (pRawBuffer + sizeofHeader + i*sizeofHit);

			if(0 == i)
			{
				difId = rawHit->m_difId;
				difSpill = rawHit->m_spillId;
			}

			// std::cout << "hit BCID " << rawHit->m_bcid << std::endl;
			// std::cout << "hit recTime " << rawHit->m_recTime << std::endl;
			// std::cout << "hit energy " << rawHit->m_energy << std::endl;
			// std::cout << "hit x " << rawHit->m_x << std::endl;
			// std::cout << "hit y " << rawHit->m_y << std::endl;
			// std::cout << "hit z " << rawHit->m_z << std::endl;
			// std::cout << "hit spill " << rawHit->m_spillId << std::endl;
			// std::cout << "hit adcCount " << rawHit->m_adcCount << std::endl;
			// std::cout << "hit dif " << (int)rawHit->m_difId << std::endl;
			// std::cout << "hit asic " << (int)rawHit->m_asicId << std::endl;
			// std::cout << "hit channel" << (int)rawHit->m_channelId << std::endl;
			// std::cout << "hit col " << (int)rawHit->m_columnId << std::endl;
			// std::cout << "hit i " << (int)rawHit->m_iCell << std::endl;
			// std::cout << "hit j " << (int)rawHit->m_jCell << std::endl;
			// std::cout << "hit layer " << (int)rawHit->m_layer << std::endl;

			
			// Perform conversion from hardware layer to layer in beam direction
			// This layer is stored as the 'real' layer.
			// The hardware layer is still accessible using the dif/asic ids
			unsigned int layer(0);
			dqm4hep::StatusCode statusCode(m_ecalHelper.getLayer(rawHit->m_layer, layer));

			if(dqm4hep::STATUS_CODE_SUCCESS != statusCode)
			{
			  LOG4CXX_ERROR( dqm4hep::dqmMainLogger, "Couldn't find hardware layer '" << (int)rawHit->m_layer << " 'in mapping" );
				continue;
			}

			// Store the layer and asic id in a map if the adc count is negative
			// The corresponding asic will be suppressed from the data after the complete loop
			if(m_negativeAdcCountSuppression && rawHit->m_adcCount < 0)
			{
				layerToAsicListMap[layer].insert(rawHit->m_asicId);
				continue;
			}

			// basic cut on adc count
			if(rawHit->m_adcCount < m_adcCountCut)
				continue;

			IMPL::CalorimeterHitImpl *pECalCaloHit = new IMPL::CalorimeterHitImpl();
			IMPL::RawCalorimeterHitImpl *pECalRawCaloHit = new IMPL::RawCalorimeterHitImpl();

			float position[3] = {
					rawHit->m_x + m_positionShift.getX(),
					rawHit->m_y + m_positionShift.getY(),
					// ATTN : beam axis rotated for ecal !!!
					-1.f * rawHit->m_z + m_positionShift.getZ() };

			// set the cell id
			// ATTN : put the corrected layer id in calorimeter hit (starting from 0 + in beam forward direction)
			// and the hardware layer in the raw calorimeter hit (starting from -1 + in beam backward direction)
			cellIDEncoder[ m_ijkEncoding.at(0) ] = rawHit->m_iCell;
			cellIDEncoder[ m_ijkEncoding.at(1) ] = rawHit->m_jCell;
			cellIDEncoder[ m_ijkEncoding.at(2) ] = layer;
			cellIDEncoder[ m_difAsicChannelEncoding.at(0) ] = rawHit->m_difId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(1) ] = rawHit->m_asicId;
			cellIDEncoder[ m_difAsicChannelEncoding.at(2) ] = rawHit->m_channelId;

			cellIDRawEncoder[ m_ijkEncoding.at(0) ] = rawHit->m_iCell;
			cellIDRawEncoder[ m_ijkEncoding.at(1) ] = rawHit->m_jCell;
			cellIDRawEncoder[ m_ijkEncoding.at(2) ] = rawHit->m_layer;
			cellIDRawEncoder[ m_difAsicChannelEncoding.at(0) ] = rawHit->m_difId;
			cellIDRawEncoder[ m_difAsicChannelEncoding.at(1) ] = rawHit->m_asicId;
			cellIDRawEncoder[ m_difAsicChannelEncoding.at(2) ] = rawHit->m_channelId;

			int adcCount = static_cast<int>(rawHit->m_adcCount);

			// ATTN : Conversion from uint64_t to uint32_t.
			// Hope this will not affect data ...
			uint32_t time = static_cast<uint32_t>(rawHit->m_bcid);

			cellIDEncoder.setCellID( pECalCaloHit );
			pECalCaloHit->setPosition(position);
			pECalCaloHit->setTime(static_cast<float>(time));

			// no energy
			if(m_energyMode == 0)
			{
				pECalCaloHit->setEnergy(0.f);
			}
			// copy energy value from raw data
			else if(m_energyMode == 1)
			{
				pECalCaloHit->setEnergy(rawHit->m_energy);
			}
			// apply pedestals and mip calibration
			else if(m_energyMode == 2)
			{
				float calibratedEnergy(0.f);

				statusCode = m_ecalHelper.getCalibratedEnergy(layer, rawHit->m_asicId, rawHit->m_channelId,
						rawHit->m_columnId, rawHit->m_adcCount, calibratedEnergy);

				if(dqm4hep::STATUS_CODE_SUCCESS == statusCode)
				{
					pECalCaloHit->setEnergy(calibratedEnergy);
				}
				else
				{
					LOG4CXX_WARN( dqm4hep::dqmMainLogger , "Couldn't apply ecal energy calibration on hit : \n" <<
							"  iCell = " << rawHit->m_iCell << "\n" <<
							"  jCell = " << rawHit->m_jCell << "\n" <<
							"  hw layer = " << rawHit->m_layer << ".\n"
							"Setting energy to 0 !");

					pECalCaloHit->setEnergy(0.f);
				}
			}
			else if(m_energyMode == 3)
			  {
			    pECalCaloHit->setEnergy(static_cast<float>(adcCount));
			  }

			cellIDRawEncoder.setCellID( pECalRawCaloHit );
			pECalRawCaloHit->setAmplitude(adcCount);
			pECalRawCaloHit->setTimeStamp(time);

			// add pointer reference to raw hit
			pECalCaloHit->setRawHit(pECalRawCaloHit);

			pOutputCollection->addElement(pECalCaloHit);
			pOutputRawCollection->addElement(pECalRawCaloHit);
		}

		std::stringstream ss;
		ss << "SIWECAL_DIF" << difId << "_Spill";

		pOutputCollection->parameters().setValue(ss.str(), static_cast<int>(difSpill));
	}

	if(m_negativeAdcCountSuppression && !layerToAsicListMap.empty())
	{
		UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder( pOutputCollection );

		for(int e=0 ; e<pOutputCollection->getNumberOfElements() ; e++)
		{
			EVENT::CalorimeterHit *pCaloHit = dynamic_cast<EVENT::CalorimeterHit *>(pOutputCollection->getElementAt(e));
			EVENT::RawCalorimeterHit *pRawCaloHit = dynamic_cast<EVENT::RawCalorimeterHit *>(pOutputRawCollection->getElementAt(e));

			unsigned int layer = cellIDDecoder(pCaloHit)[ m_ijkEncoding.at(2) ];
			unsigned int asicId = cellIDDecoder(pCaloHit)[ m_difAsicChannelEncoding.at(1) ];

			for(auto iter = layerToAsicListMap.begin(), endIter = layerToAsicListMap.end() ; endIter != iter ; ++iter)
			{
				bool found = false;

				for(auto iter2 = iter->second.begin(), endIter2 = iter->second.end() ; endIter2 != iter2 ; ++iter2)
				{
					if(iter->first == layer && *iter2 == asicId)
					{
						LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Negative adc count suppres for asic : " << asicId );

						delete pCaloHit;
						delete pRawCaloHit;

						pOutputCollection->removeElementAt(e);
						pOutputRawCollection->removeElementAt(e);

						e--;
						found = true;
					}
				}

				if(found)
					break;
			}
		}
	}

	pOutputCollection->parameters().setValue("EnergyMode", static_cast<int>(m_energyMode));
	pOutputCollection->parameters().setValue("DetectorId", static_cast<int>(m_detectorId));
	pOutputCollection->parameters().setValue("AdcCountCut", static_cast<int>(m_adcCountCut));
	pOutputCollection->parameters().setValue("NegativeAdcCountSuppression", static_cast<int>(m_negativeAdcCountSuppression));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void SiWECalShmProcessor::setCaloHitLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_LONG );  // calorimeter data -> format long (position)
	lcFlag.setBit( bitinfo.RCHBIT_BARREL ); // barrel
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // time
}

//-------------------------------------------------------------------------------------------------

void SiWECalShmProcessor::setRawCaloHitLCFlag(IMPL::LCFlagImpl &lcFlag)
{
	EVENT::LCIO bitinfo;
	lcFlag.setBit( bitinfo.RCHBIT_ID1 ); // cell ID 1
	lcFlag.setBit( bitinfo.RCHBIT_TIME ); // time
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SiWECalShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_detectorId = 1100;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"DetectorId", m_detectorId));

	m_outputCollectionName = "SIWECAL_HIT";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputCollectionName", m_outputCollectionName));

	m_outputRawCollectionName = "SiWECalHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OutputRawCollectionName", m_outputRawCollectionName));

	m_positionShift.setValues(0.f, 0.f, 0.f);
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"PositionShift", m_positionShift));

	m_cellIDEncoderString = "I:7,J:7,K-1:6,Dif_id:8,Asic_id:8,Chan_id:6";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDEncoderString", m_cellIDEncoderString));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"IJKEncoding", m_ijkEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValues(xmlHandle,
			"DifAsicChannelEncoding", m_difAsicChannelEncoding, [&] (const dqm4hep::StringVector &vec) {
		return vec.size() == 3;
	}));

	m_energyMode = 2;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"EnergyMode", m_energyMode, [] (unsigned int m) {return m<4;}));

	m_adcCountCut = 0;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"AdcCountCut", m_adcCountCut));

	m_negativeAdcCountSuppression = true;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NegativeAdcCountSuppression", m_negativeAdcCountSuppression));

	dqm4hep::TiXmlElement *pECalHelperXmlElement = xmlHandle.FirstChildElement("ecalHelper").Element();

	if(!pECalHelperXmlElement)
	{
		LOG4CXX_ERROR(dqm4hep::dqmMainLogger, "Couldn't find configuration for ecal helper <ecalHelper>");
		return dqm4hep::STATUS_CODE_NOT_FOUND;
	}

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, m_ecalHelper.readSettings(dqm4hep::TiXmlHandle(pECalHelperXmlElement)));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

FileWriterShmProcessor::FileWriterShmProcessor() :
		m_openMode(1),
		m_currentRunNumber(-1),
		m_currentSubRunNumber(0),
		m_compressionLevel(0)
{
	m_pLCWriter = IOIMPL::LCFactory::getInstance()->createLCWriter();
}

//-------------------------------------------------------------------------------------------------

FileWriterShmProcessor::~FileWriterShmProcessor()
{
	delete m_pLCWriter;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FileWriterShmProcessor::startOfRun(dqm4hep::DQMRun *const pRun)
{
	const bool newRun(pRun->getRunNumber() != m_currentRunNumber);

	if(newRun)
	{
		m_currentSubRunNumber = 0;
		m_currentRunNumber = pRun->getRunNumber();
	}
	else
	{
		++m_currentSubRunNumber;
	}

	std::stringstream fileName;
	fileName << m_fileDirectory << m_lcioFileName << "_I" << m_currentRunNumber << "_" << m_currentSubRunNumber << ".slcio";

	try
	{
		m_pLCWriter->open( fileName.str() , m_openMode );
	}
	catch(IO::IOException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Couldn't open slcio file  '" << fileName.str() << "' : " << std::string(exception.what()));
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	m_pLCWriter->setCompressionLevel(m_compressionLevel);

	// create run header
	IMPL::LCRunHeaderImpl *pLCRunHeader = new IMPL::LCRunHeaderImpl();
	pLCRunHeader->setRunNumber(m_currentRunNumber);
	pLCRunHeader->setDetectorName(pRun->getDetectorName());
	pLCRunHeader->setDescription(pRun->getDescription());

	const dqm4hep::StringVector parameterKeys(pRun->getParameterKeys());

	for(dqm4hep::StringVector::const_iterator iter = parameterKeys.begin(), endIter = parameterKeys.end() ;
			endIter != iter ; ++iter)
	{
		std::string parameter;
		pRun->getParameter<std::string>(*iter, parameter);
		pLCRunHeader->parameters().setValue(*iter, parameter);
	}

	m_pLCWriter->writeRunHeader(pLCRunHeader);
	delete pLCRunHeader;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FileWriterShmProcessor::endOfRun(const dqm4hep::DQMRun *const pRun)
{
	try
	{
		m_pLCWriter->close();
	}
	catch(IO::IOException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Couldn't close slcio file  : " << std::string(exception.what()));
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FileWriterShmProcessor::processEvent(dqm4hep::DQMEvent *pEvent, uint32_t key, const std::vector<levbdim::buffer*> &bufferList)
{
	IMPL::LCEventImpl *pLCEvent = dynamic_cast<IMPL::LCEventImpl *>(pEvent->getEvent<EVENT::LCEvent>() );

	if( ! pLCEvent )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Wrong event type ! Expecting EVENT::LCEvent type !" );
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	try
	{
		m_pLCWriter->writeEvent(pLCEvent);
	}
	catch(IO::IOException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Couldn't write lcio event  : " << std::string(exception.what()));
		return dqm4hep::STATUS_CODE_FAILURE;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FileWriterShmProcessor::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_fileDirectory = "/tmp";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"FileDirectory", m_fileDirectory));

	if(m_fileDirectory.empty())
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	if( m_fileDirectory.at(m_fileDirectory.size()-1) != '/')
		m_fileDirectory += "/";

	m_lcioFileName = "DQM_SDHCAL";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"LcioFileName", m_lcioFileName));

	if(m_lcioFileName.empty())
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	m_openMode = 1;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"OpenMode", m_openMode));

	m_compressionLevel = 1;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CompressionLevel", m_compressionLevel));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

