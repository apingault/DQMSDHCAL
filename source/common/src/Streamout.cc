  /// \file Streamout.cc
/*
 *
 * Streamout.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 3 2015
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Laurent Mirabito, Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm sdhcal headers
#include "Streamout.h"
#include "DIFUnpacker.h"
#include "DIF.h"

// -- lcio headers
#include "EVENT/LCIO.h"
#include "Exceptions.h"
#include "EVENT/LCEvent.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCGenericObjectImpl.h"
#include "IMPL/RawCalorimeterHitImpl.h"
#include "IMPL/LCFlagImpl.h"

#include "streamlog/streamlog.h"

namespace dqm_sdhcal
{

class LMGeneric: public IMPL::LCGenericObjectImpl
{
public:
	/** Constructor
	 */
	LMGeneric()
	{
		/* nop */
	}

	/** Get the int vector (reference)
	 */
	std::vector<int>& getIntVector()
	{
		return _intVec;
	}
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

Streamout::Streamout() :
		m_ruShift(23),
		m_xdaqShift(24),
		m_inputCollectionName("RU_XDAQ"),
		m_outputCollectionName("DHCALRawHits"),
		m_dropFirstRU(true),
		m_skipFullAsics(true)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

Streamout::~Streamout()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode Streamout::processEvent(EVENT::LCEvent *pLCEvent)
{
	// grab the input collection
	EVENT::LCCollection *pLCCollection = NULL;

	try
	{
		pLCCollection = pLCEvent->getCollection(m_inputCollectionName);
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
	  streamlog_out(ERROR) << "Input collection name not found : " << m_inputCollectionName << std::endl;
		return dqm4hep::STATUS_CODE_NOT_FOUND;
	}

	if(NULL == pLCCollection)
		return dqm4hep::STATUS_CODE_FAILURE;

	// check collection type
	if(EVENT::LCIO::LCGENERICOBJECT != pLCCollection->getTypeName())
		return dqm4hep::STATUS_CODE_INVALID_PARAMETER;

	// create the output collection
	IMPL::LCCollectionVec *pRawCalorimeterHitCollection = new IMPL::LCCollectionVec(EVENT::LCIO::RAWCALORIMETERHIT);

	// configure it
	IMPL::LCFlagImpl chFlag(0) ;
	EVENT::LCIO bitinfo;
	chFlag.setBit(bitinfo.RCHBIT_LONG); // raw calorimeter data -> format long
	chFlag.setBit(bitinfo.RCHBIT_BARREL); // barrel
	chFlag.setBit(bitinfo.RCHBIT_ID1); // cell ID
	chFlag.setBit(bitinfo.RCHBIT_TIME); // timestamp
	pRawCalorimeterHitCollection->setFlag(chFlag.getFlag());

	// convert the input elements to DIFPtrs
	for(unsigned int e=0 ; e<pLCCollection->getNumberOfElements() ; e++)
	{
		if(e == 0 && m_dropFirstRU)
			continue;

		LMGeneric *pLCGenericObject = (LMGeneric *)(pLCCollection->getElementAt(e));

		if(NULL == pLCGenericObject)
			continue;

		// grab the generic object contents
		int *pGenericRawBuffer = &(pLCGenericObject->getIntVector()[0]);
		unsigned char *pRawBuffer = (unsigned char *)pGenericRawBuffer;
		uint32_t ruSize = pLCGenericObject->getNInt()*sizeof(int32_t);
		uint32_t idStart = DIFUnpacker::getStartOfDIF(pRawBuffer, ruSize, m_xdaqShift);

		// create the DIF ptr
		unsigned char *pDifRawBuffer = &pRawBuffer[idStart];
		DIFPtr *pDifPtr = new DIFPtr(pDifRawBuffer, ruSize-idStart+1);

		for(unsigned int f=0 ; f<pDifPtr->getNumberOfFrames() ; f++)
		{
			// find whether the dif has full asics
			if(m_skipFullAsics)
			{
				unsigned int touchedChannels = 0;

				for(unsigned int ch=0 ; ch<64 ; ch++)
				{
					if(!(pDifPtr->getFrameLevel(f, ch, 0) || pDifPtr->getFrameLevel(f, ch, 1)))
						continue;

					touchedChannels++;
				}

				if(64 == touchedChannels)
					continue;
			}

			// create the raw calorimeter hits
			for(unsigned int ch=0 ; ch<64 ; ch++)
			{
				// skip empty pads
				if(!(pDifPtr->getFrameLevel(f, ch, 0) || pDifPtr->getFrameLevel(f, ch, 1)))
					continue;

				unsigned long int id0 = 0;
				unsigned long int id1 = 0;
				unsigned long barrelEndcapModule = 0;
				// time stamp of this event from Run Begining
				unsigned long int timeStamp = (unsigned long int)(pDifPtr->getFrameTimeToTrigger(f));
				std::bitset<6> channel(ch);
				std::bitset<3> amplitudeBitSet;

				// 8 firsts bits: DIF Id
				id0 = (unsigned long int)(((unsigned short)pDifPtr->getID())&0xFF);

				// 8 next bits:   Asic Id
				id0 += (unsigned long int)(((unsigned short)pDifPtr->getFrameAsicHeader(f)<<8)&0xFF00);

				//6 next bits:   Asic's Channel
				id0 += (unsigned long int)((channel.to_ulong()<<16)&0x3F0000);

				  //(40 barrel + 24 endcap) modules to be coded here 0 for testbeam (over 6 bits)
				id0+=(unsigned long int)((barrelEndcapModule<<22)&0xFC00000);

				// cell id 1
				id1 = (unsigned long int)(pDifPtr->getFrameBCID(f));

				amplitudeBitSet[0] = pDifPtr->getFrameLevel(f, ch, 0);
				amplitudeBitSet[1] = pDifPtr->getFrameLevel(f, ch, 1);
				amplitudeBitSet[2] = true; // always synchronized ?

				IMPL::RawCalorimeterHitImpl *pRawCalorimeterHit = new IMPL::RawCalorimeterHitImpl();

				pRawCalorimeterHit->setCellID0(id0);
				pRawCalorimeterHit->setCellID1(id1);
				pRawCalorimeterHit->setAmplitude(amplitudeBitSet.to_ulong());
				pRawCalorimeterHit->setTimeStamp(timeStamp);

				pRawCalorimeterHitCollection->addElement(pRawCalorimeterHit);
			}
		}

		EVENT::IntVec trigger(8);

		trigger[0] = pDifPtr->getDTC();
		trigger[1] = pDifPtr->getGTC();
		trigger[2] = pDifPtr->getBCID();
		trigger[3] = pDifPtr->getAbsoluteBCID()&0xFFFFFF;
		trigger[4] = (pDifPtr->getAbsoluteBCID()/(0xFFFFFF+1))&0xFFFFFF;
		trigger[5] = pDifPtr->getTASU1();
		trigger[6] = pDifPtr->getTASU2();
		trigger[7] = pDifPtr->getTDIF();

		std::stringstream parameterKey;
		parameterKey << "DIF" << pDifPtr->getID() << "_Triggers";

		pRawCalorimeterHitCollection->parameters().setValues(parameterKey.str(), trigger);
	}

	// check if any hits have been added to the collection
	// should never happened except if empty event
	if(pRawCalorimeterHitCollection->getNumberOfElements() == 0)
	{
		std::cout << "No raw calorimeter hits produced !" << std::endl;
		delete pRawCalorimeterHitCollection;
		return dqm4hep::STATUS_CODE_SUCCESS;
	}

	// add the collection to event
	try
	{
		pLCEvent->addCollection(pRawCalorimeterHitCollection, m_outputCollectionName);
	}
	catch(IO::IOException &exception)
	{
		std::cout << "Couldn't add collection : " << m_outputCollectionName << std::endl;
		delete pRawCalorimeterHitCollection;
		return dqm4hep::STATUS_CODE_ALREADY_PRESENT;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setRuShift(int ruShift)
{
	m_ruShift = ruShift;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setXDaqShift(unsigned int shift)
{
	m_xdaqShift = shift;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setInputCollectionName(const std::string &collectionName)
{
	m_inputCollectionName = collectionName;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setOutputCollectionName(const std::string &collectionName)
{
	m_outputCollectionName = collectionName;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setDropFirstRU(bool drop)
{
	m_dropFirstRU = drop;
}

//-------------------------------------------------------------------------------------------------

void Streamout::setSkipFullAsic(bool skip)
{
	m_skipFullAsics = skip;
}

} 

