/// \file ECalAnalysisModule.cc
/*
 *
 * ECalAnalysisModule.cc source template automatically generated by a class generator
 * Creation date : ven. aoï¿½t 28 2015
 *
 * This file is part of DQMSDHCAL libraries.
 *
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete, Arnaud Steen
 * @copyright CNRS , IPNL
 */


#include "ECalAnalysisModule.h"

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMPluginManager.h"

// -- lcio headers
#include <EVENT/LCCollection.h>
#include <EVENT/CalorimeterHit.h>
#include <EVENT/RawCalorimeterHit.h>
#include <UTIL/CellIDDecoder.h>
#include <UTIL/LCTOOLS.h>

// -- dqmsdhcal headers
#include <AnalysisTools.h>

using namespace dqm4hep;

namespace dqm_sdhcal
{

// plugin declaration
DQM_PLUGIN_DECL( ECalAnalysisModule, "ECalAnalysisModule" )

ECalAnalysisModule::ECalAnalysisModule() :
	DQMTriventModule(),
	m_moduleLogStr("[ECalAnalysisModule]"),
	m_nActiveLayers(0)
{
}

//-------------------------------------------------------------------------------------------------

ECalAnalysisModule::~ECalAnalysisModule()
{
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::userReadSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_nActiveLayers = 10;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NActiveLayers", m_nActiveLayers));

	m_cellIDDecoderString = "M:3,S-1:3,I:9,J:9,K-1:6";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"CellIDDecoderString", m_cellIDDecoderString));

	m_inputCollectionName = "SIWECAL_HIT";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"InputCollectionName", m_inputCollectionName));

	/*-----------------------------------------------------*/
	m_pNHitDistribution = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"NHitDistribution", m_pNHitDistribution));

	m_pAdcCountDistribution = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"AdcCountDistribution", m_pAdcCountDistribution));

	m_pTotalEnergyDistribution = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"TotalEnergyDistribution", m_pTotalEnergyDistribution));

	m_pHitEnergyDistribution = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"HitEnergyDistribution", m_pHitEnergyDistribution));

	// Monitor elements per layer
	for (unsigned int layerId = 0 ; layerId < m_nActiveLayers ; layerId++)
	{
		DQMParameters parameters;
		parameters["layerId"]= std::to_string(layerId);

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
				"LayerNumberOfHits", m_layerElementMap[layerId].m_pNHit, parameters));

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
				"LayerTotalEnergy", m_layerElementMap[layerId].m_pEnergy, parameters));

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
				"LayerHitMap", m_layerElementMap[layerId].m_pHitMap, parameters));

		RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
				"LayerEnergyMap", m_layerElementMap[layerId].m_pEnergyMap, parameters));
	}

	m_pNHitFromSOA = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"NHitFromSOA", m_pNHitFromSOA));

	m_pNHitFromSOS = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"NHitFromSOS", m_pNHitFromSOS));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::userInitModule()
{
	return STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
dqm4hep::StatusCode ECalAnalysisModule::processEvent(EVENT::LCEvent *pLCEvent)
{
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Processing physics event no " << pLCEvent->getEventNumber() );

	try
	{
	  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Getting input collection");
		EVENT::LCCollection *pLCCollection = pLCEvent->getCollection(m_inputCollectionName);
		UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder(m_cellIDDecoderString);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " - Init analysis vars");
		unsigned int nHits(0);
		float totalEnergy(0.f);
		std::vector<unsigned int> nHitsPerLayer(m_nActiveLayers, 0);
		std::vector<float> totalEnergyPerLayer(m_nActiveLayers, 0.f);

		std::cout << "NHIT = " << pLCCollection->getNumberOfElements() << std::endl;

		for(unsigned int i=0 ; i<pLCCollection->getNumberOfElements() ; ++i)
		{
			EVENT::CalorimeterHit *pCaloHit = dynamic_cast<EVENT::CalorimeterHit*>(pLCCollection->getElementAt(i));

			if(NULL == pCaloHit)
				continue;

			const unsigned int iCell = cellIDDecoder(pCaloHit)["I"];
			const unsigned int jCell = cellIDDecoder(pCaloHit)["J"];
			const unsigned int layer = cellIDDecoder(pCaloHit)["K-1"];

			if(layer >= m_nActiveLayers)
				continue;

			const float energy(pCaloHit->getEnergy());

			++nHits;
			totalEnergy += energy;

			m_pHitEnergyDistribution->get<TH1>()->Fill(energy);

			nHitsPerLayer.at(layer) ++;
			totalEnergyPerLayer.at(layer) += energy;

			m_layerElementMap[layer].m_pHitMap->get<TH2>()->Fill(iCell, jCell, 1);
			m_layerElementMap[layer].m_pEnergyMap->get<TH2>()->Fill(iCell, jCell, energy);

			EVENT::RawCalorimeterHit *pRawCaloHit = dynamic_cast<EVENT::RawCalorimeterHit*>(pCaloHit->getRawHit());

			if(pRawCaloHit)
			{
				m_pAdcCountDistribution->get<TH1>()->Fill(pRawCaloHit->getAmplitude());
			}
		}

		unsigned int nTouchedLayers(0);

		for(unsigned int l=0 ; l<m_nActiveLayers ; ++l)
		{
			const unsigned int nHitInLayer(nHitsPerLayer.at(l));
			const float energyInLayer(totalEnergyPerLayer.at(l));

			if(nHitInLayer != 0)
				nTouchedLayers++;

			m_layerElementMap[l].m_pNHit->get<TH1>()->Fill(nHitInLayer);
			m_layerElementMap[l].m_pEnergy->get<TH1>()->Fill(energyInLayer);
		}

		m_pTotalEnergyDistribution->get<TH1>()->Fill(totalEnergy);
		m_pNHitDistribution->get<TH1>()->Fill(nHits);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , m_moduleLogStr << " n hits : " << nHits << " , total energy = " << totalEnergy << " , n touched layers " << nTouchedLayers);
	}
	catch (EVENT::DataNotAvailableException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , m_moduleLogStr << "Caught EVENT::DataNotAvailableException : " << exception.what());
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger ,  m_moduleLogStr << "Skipping event" );
		return STATUS_CODE_SUCCESS;
	}
	catch (std::exception &exception)
	{
	  LOG4CXX_DEBUG( dqm4hep::dqmMainLogger ,  m_moduleLogStr << "Caught exception : " << exception.what());
		return STATUS_CODE_FAILURE;
	}
	catch (...)
	{
		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger ,  m_moduleLogStr << "Caught unknown exception !");
		return STATUS_CODE_FAILURE;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::startOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::endOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::startOfRun(DQMRun * pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::endOfRun(DQMRun * pRun)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode ECalAnalysisModule::endModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

}

