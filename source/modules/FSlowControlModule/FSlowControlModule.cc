/*
 *
 * FSlowControlModule.cc source template automatically generated by a class generator
 * Creation date : mar. Septembre 5 2017
 *
 * This file is part of DQMSDHCAL libraries.
 *
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete, Antoine Pingault
 * @copyright CNRS , IPNL
 */


#include "FSlowControlModule.h"

// -- dqm4hep headers
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMCoreTool.h"

// -- json headers
#include "json/json.h"
#include "dic.hxx"

// -- root headers
#include "TGraph.h"

namespace dqm_sdhcal
{
DQM_PLUGIN_DECL(FSlowControlModule, "FSlowControlModule")

//-------------------------------------------------------------------------------------------------

CurrentQualityTest::CurrentQualityTest(const std::string& name) :
  DQMQualityTest(name),
  m_maxAllowedCurrent(0),
  m_maxDangerousCurrent(0)
{
  /* nop */
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
  m_maxAllowedCurrent = -6;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "MaxAllowedCurrent", m_maxAllowedCurrent));

  m_maxDangerousCurrent = -10;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "MaxDangerousCurrent", m_maxDangerousCurrent));

  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::init()
{
  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::run(dqm4hep::DQMMonitorElement *pMonitorElement)
{
  const float currentCategory(static_cast<float>(m_maxAllowedCurrent) / 2.f);

  TGraph *pCurrentGraph = pMonitorElement->get<TGraph>();

  if (pCurrentGraph->GetN() == 0)
  {
    m_isSuccessful = false;
    m_message      = "No points for current quality check !";
    m_quality      = dqm4hep::NO_QUALITY;

    return dqm4hep::STATUS_CODE_SUCCESS;
  }

  float current = pCurrentGraph->GetY()[pCurrentGraph->GetN() - 1];

  if (current > currentCategory)
  {
    m_message = "Very good current (${limit} < I µA)";
    dqm4hep::DQM4HEP::replace(m_message, "limit", currentCategory);
    m_quality = dqm4hep::VERY_GOOD_QUALITY;
  }
  else if (current > 2.f * currentCategory)
  {
    m_message = "Rather good current (${lLimit} < I < ${uLimit} µA)";
    dqm4hep::DQM4HEP::replace(m_message, "lLimit", 2.f * currentCategory);
    dqm4hep::DQM4HEP::replace(m_message, "uLimit", currentCategory);
    m_quality = dqm4hep::GOOD_QUALITY;
  }
  else if (current > m_maxDangerousCurrent)
  {
    m_message = "Bad current !! Check it now !!! (${lLimit} < I < ${uLimit} µA)";
    dqm4hep::DQM4HEP::replace(m_message, "lLimit", m_maxDangerousCurrent);
    dqm4hep::DQM4HEP::replace(m_message, "uLimit", m_maxAllowedCurrent);
    m_quality = dqm4hep::BAD_QUALITY;
  }
  else
  {
    m_message = "SIR ! SIR ! ON EN A GROS !! (I < ${uLimit} µA)";
    dqm4hep::DQM4HEP::replace(m_message, "uLimit", m_maxDangerousCurrent);
    m_quality = dqm4hep::VERY_BAD_QUALITY;
  }

  m_isSuccessful = true;

  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

bool CurrentQualityTest::canRun(dqm4hep::DQMMonitorElement *pMonitorElement) const
{
  return(pMonitorElement->get<TGraph>() != 0);
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

FSlowControlModule::FSlowControlModule() :
  dqm4hep::DQMStandaloneModule(),
  m_startTime(0),
  m_globalDynamicGraphRange(0),
	m_slowControlName(""),
	m_hostName(""),
	m_hostPort(""),
	m_nChamber(48)
{
  /* nop */
}


//-------------------------------------------------------------------------------------------------

FSlowControlModule::~FSlowControlModule()
{
  /* nop */
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::registerQualityTestFactory(this,
                                                                                                       "CurrentQualityTest", new CurrentQualityTest::Factory()));

  m_startTime = time(0);

  // settings
	m_slowControlName = "FSLOW";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
		"SlowControlName", m_slowControlName));
		
	m_hostName = "lyosdhcal12";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
		"HostName", m_hostName));
		
	m_hostPort = "36000";
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
		"HostPort", m_hostPort));
	
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "LVInfo", m_lvInfoName));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "HVInfo", m_hvInfoName));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "TemperatureInfo", m_temperatureInfoName));

  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "PressureInfo", m_pressureInfoName));

  m_globalDynamicGraphRange = 60 * 60;   // default is 1h
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
                                                                                               "GlobalDynamicGraphRange", m_globalDynamicGraphRange));


  // monitor elements
  m_pGlobalTemperatureElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "GlobalTemperature", m_pGlobalTemperatureElement));

  m_pGlobalPressureElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "GlobalPressure", m_pGlobalPressureElement));

  m_pHighVoltageVSetElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "VSet", m_pHighVoltageVSetElement));

  m_pHighVoltageVReadElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "VRead", m_pHighVoltageVReadElement));

  m_pHighVoltageVSetReadDiffElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "VSetVReadDiff", m_pHighVoltageVSetReadDiffElement));

  m_pHighVoltageISetElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "ISet", m_pHighVoltageISetElement));

  m_pHighVoltageIReadElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "IRead", m_pHighVoltageIReadElement));

  m_pHighVoltageISetReadDiffElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "ISetIReadDiff", m_pHighVoltageISetReadDiffElement));

  m_pLowVoltageElement = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "LowVoltage", m_pLowVoltageElement));

  m_pLowVoltageStatus = NULL;
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                               "LowVoltageStatus", m_pLowVoltageStatus));

  this->configureGraph(m_pGlobalTemperatureElement->get<TGraph>());
  m_pGlobalTemperatureElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);
  m_pGlobalTemperatureElement->setDescription("Global temperature graph from a device near (outside probe) the SDHCAL detector. \n"
                                              "X axis is time in seconds from the module start time ( t0 = " + dqm4hep::DQM4HEP::typeToString(m_startTime) + ")");

  this->configureGraph(m_pGlobalPressureElement->get<TGraph>());
  m_pGlobalPressureElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);
  m_pGlobalPressureElement->setDescription("Global pressure graph from a device near (outside probe) the SDHCAL detector. \n"
                                           "X axis is time in seconds from the module start time ( t0 = " + dqm4hep::DQM4HEP::typeToString(m_startTime) + ")");

  this->configureGraph(m_pHighVoltageVSetElement->get<TGraph>());
  this->configureGraph(m_pHighVoltageVReadElement->get<TGraph>());
  this->configureGraph(m_pHighVoltageVSetReadDiffElement->get<TGraph>());
  this->configureGraph(m_pHighVoltageISetElement->get<TGraph>());
  this->configureGraph(m_pHighVoltageIReadElement->get<TGraph>());
  this->configureGraph(m_pHighVoltageISetReadDiffElement->get<TGraph>());


  // book HV plot per chamber using current dim info
  // int nServices = browser.getServices((char *)m_hvInfoName.c_str());
	int nServices = m_nChamber;

  if (0 != nServices)
  {
		char *pServiceName, *pFormat;
		int serviceType;

    while (1)
    {
			
      DimCurrentInfo hvDimInfo(pServiceName, (void *)NULL, 0);
      HVInfo         *pDimHVInfo = (HVInfo *)hvDimInfo.getData();
      int            dimDataSize = hvDimInfo.getSize();

      if ((0 == pDimHVInfo) || (0 == dimDataSize))
      {
        continue;
      }

      if (pDimHVInfo->m_chamberID < 0)
      {
        continue;
      }

      unsigned int chamberID = pDimHVInfo->m_chamberID;

      if (m_chamberHVElementMap.find(chamberID) != m_chamberHVElementMap.end())
      {
        continue;
      }

      LOG4CXX_DEBUG(dqm4hep::dqmMainLogger, "Booking HV graph for chamber id = " << chamberID);

      dqm4hep::DQMMonitorElementPtr monitorElement;
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                                   "VReadPerLayer", chamberID, monitorElement));

      this->configureGraph(monitorElement->get<TGraph>());
      monitorElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);

      m_chamberHVElementMap[chamberID] = monitorElement;

      monitorElement = 0;
      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                                                                                                   "IReadPerLayer", chamberID, monitorElement));

      this->configureGraph(monitorElement->get<TGraph>());
      monitorElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);

      m_chamberCurrentElementMap[chamberID] = monitorElement;

      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::createQualityTest(this, xmlHandle,
                                                                                                  "CurrentCheckQuality"));

      RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::addQualityTest(this,
                                                                                               monitorElement, "CurrentCheckQuality"));
    }
  }


  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

std::string FSlowControlModule::sendCmd(const char *cmd)
{
	LOG4CXX_DEBUG ( dqm4hep::dqmMainLogger, "Cmd : " << cmd );
  FILE *pipe = popen(cmd, "r");
  if (!pipe)
  {
    return "ERROR";
  }
  char        buffer[128];
  std::string result = "";
  while (!feof(pipe))
  {
    if (fgets(buffer, 128, pipe) != NULL)
    {
      result += buffer;
    }
  }
  pclose(pipe);
  LOG4CXX_DEBUG ( dqm4hep::dqmMainLogger, "RESULT = " << result );
  return result;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::getLowVoltageInfo(LVInfo& lvInfo)
{
  // initialize to zero for security
  lvInfo.m_vSet  = 0.f;
  lvInfo.m_vRead = 0.f;
  lvInfo.m_iRead = 0.f;
  lvInfo.m_status = "NA";

  std::stringstream sc;
  sc << "curl -gsS http://" << m_hostName << ":" << m_hostPort << "/" << m_slowControlName << "/CMD?name=LVSTATUS";

	Json::Reader      reader;
	Json::Value       root;
  const std::string jsonAnswer = sendCmd(sc.str().c_str());
  if ( true != reader.parse(jsonAnswer, root))
	{
		LOG4CXX_INFO(dqm4hep::dqmMainLogger, "YOU'RE A FAILURE JSON");
		return dqm4hep::STATUS_CODE_FAILURE;
	}	
	
  const Json::Value answer = root["answer"]["STATUS"];
  // const Json::Value answer = root["answer"];
  // const Json::Value status = answer["STATUS"];
  lvInfo.m_iRead = answer["iout"].asInt();
  lvInfo.m_vRead = answer["vout"].asInt();
  lvInfo.m_vSet  = answer["vset"].asInt();
  lvInfo.m_status  = answer["status"].asString();
	
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::initModule()
{
  LOG4CXX_INFO(dqm4hep::dqmMainLogger, "TEST");
  LVInfo lvInfo;

  getLowVoltageInfo(lvInfo);
	LOG4CXX_INFO(dqm4hep::dqmMainLogger, "m_iRead " << lvInfo.m_iRead);
	LOG4CXX_INFO(dqm4hep::dqmMainLogger, "m_vRead " << lvInfo.m_vRead);
	LOG4CXX_INFO(dqm4hep::dqmMainLogger, "m_vSet " << lvInfo.m_vSet);
	LOG4CXX_INFO(dqm4hep::dqmMainLogger, "m_status " << lvInfo.m_status);
	HVInfo hvInfo;
	getHighVoltageInfos(hvInfo, 2);
	exit(-1);


  // scan dns and find hv service list
  LOG4CXX_INFO(dqm4hep::dqmMainLogger, "Scanning Dns for HV services");

  DimBrowser browser;
  int        nServices = browser.getServices((char *)m_hvInfoName.c_str());

  if (0 == nServices)
  {
    LOG4CXX_ERROR(dqm4hep::dqmMainLogger, "No HV service found for input service name '" << m_hvInfoName << "'");
    return dqm4hep::STATUS_CODE_NOT_FOUND;
  }

  char *pServiceName, *pFormat;
  int  serviceType;

  while (1)
  {
    serviceType = browser.getNextService(pServiceName, pFormat);

    if (0 == serviceType)
    {
      break;
    }

    // looking for service. No command, no rpc
    if (DimSERVICE != serviceType)
    {
      continue;
    }

    LOG4CXX_DEBUG(dqm4hep::dqmMainLogger, "Found HV service : " << pServiceName << " , format : " << pFormat);

    m_hvInfoServiceNames.push_back(pServiceName);
  }

  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::startOfCycle()
{
  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::process()
{
  std::string currentTimeStr;
  time_t      currentTime = time(0);
  dqm4hep::DQMCoreTool::timeToHMS(currentTime, currentTimeStr);

  // get and fill temperature and pressure
  float temperature = this->getGlobalTemperature();
  m_pGlobalTemperatureElement->setTitle("Global temperature (" + currentTimeStr + ")");
  m_pGlobalTemperatureElement->get<dqm4hep::TDynamicGraph>()->AddPoint(currentTime - m_startTime, temperature);

  float pressure = this->getGlobalPressure();
  m_pGlobalPressureElement->setTitle("Global pressure (" + currentTimeStr + ")");
  m_pGlobalPressureElement->get<dqm4hep::TDynamicGraph>()->AddPoint(currentTime - m_startTime, pressure);

  // get lv info
  LVInfo lvInfo;
  this->getLowVoltageInfo(lvInfo);

  std::stringstream lvText;
  lvText << "Low voltage : "
         << lvInfo.m_vSet << " V (set) / "
         << lvInfo.m_vRead << " V (read) / "
         << lvInfo.m_iRead << " A (read)";

  m_pLowVoltageElement->get<dqm4hep::TScalarString>()->Set(lvText.str());
  m_pLowVoltageElement->setTitle("Low voltage (" + currentTimeStr + ")");


  // get hv info for each chamber
  HVInfoMap hvInfoMap;
  this->getHighVoltageInfos(hvInfoMap);

  if (!hvInfoMap.empty())
  {
    // reset TGraphs
    m_pHighVoltageVSetElement->get<TGraph>()->Set(0);
    m_pHighVoltageVReadElement->get<TGraph>()->Set(0);
    m_pHighVoltageVSetReadDiffElement->get<TGraph>()->Set(0);
    m_pHighVoltageISetElement->get<TGraph>()->Set(0);
    m_pHighVoltageIReadElement->get<TGraph>()->Set(0);
    m_pHighVoltageISetReadDiffElement->get<TGraph>()->Set(0);

    int pointID = 0;

    for (HVInfoMap::iterator iter = hvInfoMap.begin(), endIter = hvInfoMap.end();
         endIter != iter; ++iter)
    {
      m_pHighVoltageVSetElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_vSet);
      m_pHighVoltageVSetElement->setTitle("High voltage (VSet) [" + currentTimeStr + "]");

      m_pHighVoltageVReadElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_vRead);
      m_pHighVoltageVReadElement->setTitle("High voltage (VRead) [" + currentTimeStr + "]");

      m_pHighVoltageVSetReadDiffElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_vSet - iter->second.m_vRead);
      m_pHighVoltageVSetReadDiffElement->setTitle("High voltage (VSet - VRead) [" + currentTimeStr + "]");


      m_pHighVoltageISetElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_iSet);
      m_pHighVoltageISetElement->setTitle("High voltage (ISet) [" + currentTimeStr + "]");

      m_pHighVoltageIReadElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_iRead);
      m_pHighVoltageIReadElement->setTitle("High voltage (IRead) [" + currentTimeStr + "]");

      m_pHighVoltageISetReadDiffElement->get<TGraph>()->SetPoint(pointID, iter->first, iter->second.m_iSet - iter->second.m_iRead);
      m_pHighVoltageISetReadDiffElement->setTitle("High voltage (ISet - IRead) [" + currentTimeStr + "]");

      DQMMonitorElementIDMap::iterator hvChIter = m_chamberHVElementMap.find(iter->first);

      if (hvChIter != m_chamberHVElementMap.end())
      {
        hvChIter->second->get<dqm4hep::TDynamicGraph>()->AddPoint(currentTime - m_startTime, iter->second.m_vRead);
        hvChIter->second->setTitle("High voltage (VSet). Chamber id " + dqm4hep::DQM4HEP::typeToString(iter->first) + ". [" + currentTimeStr + "]");
      }

      DQMMonitorElementIDMap::iterator iChIter = m_chamberCurrentElementMap.find(iter->first);

      if (iChIter != m_chamberCurrentElementMap.end())
      {
        iChIter->second->get<dqm4hep::TDynamicGraph>()->AddPoint(currentTime - m_startTime, iter->second.m_iRead);
        iChIter->second->setTitle("Current (IRead). Chamber id " + dqm4hep::DQM4HEP::typeToString(iter->first) + ". [" + currentTimeStr + "]");
      }

      pointID++;
    }
  }

  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::endOfCycle()
{
  // run all quality tests on all monitor elements
  RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::runQualityTests(this));

  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::endModule()
{
  return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

float FSlowControlModule::getGlobalTemperature()
{
  DimCurrentInfo temperatureInfo((char *)m_temperatureInfoName.c_str(), 0.f);

  return temperatureInfo.getFloat();
}


//-------------------------------------------------------------------------------------------------

float FSlowControlModule::getGlobalPressure()
{
  DimCurrentInfo pressureInfo((char *)m_pressureInfoName.c_str(), 0.f);

  return pressureInfo.getFloat();
}


//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode FSlowControlModule::getHighVoltageInfos(HVInfo& hvInfo, int chamberID)
{
	hvInfo.m_chamberID  = chamberID;
	hvInfo.m_vSet = 0.f;
	hvInfo.m_iSet = 0.f;
	hvInfo.m_vRead = 0.f;
	hvInfo.m_iRead = 0.f;
	
	std::stringstream sc;
	sc << "curl -gsS http://" << m_hostName << ":" << m_hostPort << "/" << m_slowControlName << "/CMD?name=HVSTATUS\&first="<< chamberID << "\&last="<< chamberID;

	Json::Reader      reader;
	Json::Value       root;
	const std::string jsonAnswer = sendCmd(sc.str().c_str());
	if ( true != reader.parse(jsonAnswer, root))
	{
		LOG4CXX_INFO(dqm4hep::dqmMainLogger, "YOU'RE A FAILURE JSON HSingle");
		return dqm4hep::STATUS_CODE_FAILURE;
	}	

	const Json::Value channel = root["answer"]["STATUS"]["channels"];
		if (chamberID != channel["id"].asInt())
			LOG4CXX_INFO(dqm4hep::dqmMainLogger, "Wrong Channel ID");
		
		hvInfo.m_vSet = channel["vset"].asFloat();
		hvInfo.m_iSet = channel["iset"].asFloat();
		hvInfo.m_vRead = channel["vout"].asFloat();
		hvInfo.m_iRead = channel["iout"].asFloat();
		return dqm4hep::STATUS_CODE_SUCCESS;

}

dqm4hep::StatusCode FSlowControlModule::getHighVoltageInfos(HVInfoMap& hvInfoMap)
{
//   hvInfoMap.clear();
// 
// 	// initialize to zero for security
// 	hvInfo.m_chamberID  = 0;
// 	hvInfo.m_vSet = 0.f;
// 	hvInfo.m_iSet = 0.f;
// 	hvInfo.m_vRead = 0.f;
// 	hvInfo.m_iRead = 0.f;
// 
// 	int firstChamber = hvInfoMap.begin()->m_chamberID;
// 	int lastChamber = hvInfoMap.end()->m_chamberID;
// 	
// 	std::stringstream sc;
// 	sc << "curl -gsS http://" << m_hostName << ":" << m_hostPort << "/" << m_slowControlName << "/CMD?name=HVSTATUS\&first="<< firstChamber << "\&last="<< lastChamber;
// 
// 	Json::Reader      reader;
// 	Json::Value       root;
// 	const std::string jsonAnswer = sendCmd(sc.str().c_str());
// 	if ( true != reader.parse(jsonAnswer, root))
// 	{
// 		LOG4CXX_INFO(dqm4hep::dqmMainLogger, "YOU'RE A FAILURE JSON HV");
// 		return dqm4hep::STATUS_CODE_FAILURE;
// 	}	
// 
// 	const Json::Value answer = root["answer"]["STATUS"]
// 	for (auto channel : answer["channels"]) {
// 		chanId = channel["id"];
// 		hvInfoMap.find().m_chamberID = channel["id"];
// 		hvInfo.m_vSet = channel["vset"];
// 		hvInfo.m_iSet = channel["iset"];
// 		hvInfo.m_vRead = channel["vout"];
// 		hvInfo.m_iRead = channel["iout"];
// 	}
// 
// 
// 
//   for (dqm4hep::StringVector::const_iterator iter = m_hvInfoServiceNames.begin(), endIter = m_hvInfoServiceNames.end();
//        endIter != iter; ++iter)
//   {
//     std::string serviceName = *iter;
// 
//     // get chamber hv info
//     DimCurrentInfo hvDimInfo((char *)serviceName.c_str(), (void *)NULL, 0);
//     HVInfo         *pDimHVInfo = (HVInfo *)hvDimInfo.getData();
//     int            dimDataSize = hvDimInfo.getSize();
// 
//     if ((0 == pDimHVInfo) || (0 == dimDataSize))
//     {
//       continue;
//     }
// 
//     if (pDimHVInfo->m_chamberID < 0)
//     {
//       continue;
//     }
// 
//     hvInfoMap[pDimHVInfo->m_chamberID] = *pDimHVInfo;
//   }
		return dqm4hep::STATUS_CODE_SUCCESS;
}


//-------------------------------------------------------------------------------------------------

void FSlowControlModule::configureGraph(TGraph *pGraph)
{
  if (!pGraph)
  {
    return;
  }

  pGraph->SetMarkerStyle(23);
  pGraph->SetMarkerSize(1);
  pGraph->SetMarkerColor(kBlack);
}
}
