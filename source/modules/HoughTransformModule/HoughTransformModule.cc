/*
 *
 * HoughTransformModule.cc source template automatically generated by a class generator
 * Creation date : jeu. mars 10 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "HoughTransformModule.h"

#include "CaloObject/CaloHit.h"
#include "CaloObject/CaloCluster.h"
#include "CaloObject/CaloTrack.h"
#include "Algorithm/Tracking.h"
#include "Algorithm/ClusteringHelper.h"
#include "Algorithm/Cluster.h"
#include "Algorithm/Hough.h"

//-- lcio headers
#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <IMPL/CalorimeterHitImpl.h>
#include <IMPL/LCCollectionVec.h>
#include <IMPL/LCFlagImpl.h>
#include <IMPL/LCRelationImpl.h>
#include <EVENT/LCParameters.h>
#include <UTIL/CellIDDecoder.h>

// -- dqm4hep headers
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMEvent.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMPlugin.h"

#include <algorithm>

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( HoughTransformModule , "HoughTransformModule" )

//-------------------------------------------------------------------------------------------------

		HoughTransformModule::HoughTransformModule() :
		DQMTriventModule(),
		m_nECalLayers(0)
{

}

//-------------------------------------------------------------------------------------------------

HoughTransformModule::~HoughTransformModule()
{

}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::userInitModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::userReadSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_ecalCollectionName = "SiWECalHits";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"m_ecalCollectionName", m_ecalCollectionName));

	m_hcalCollectionName = "SDHCAL_HIT";
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"HcalCollectionName", m_hcalCollectionName));

	m_nECalLayers = 6;
	RETURN_RESULT_IF_AND_IF(dqm4hep::STATUS_CODE_SUCCESS, dqm4hep::STATUS_CODE_NOT_FOUND, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"NECalLayers", m_nECalLayers));

	m_pNRecTracks = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"NRecTracks", m_pNRecTracks));

	m_pTrackChi2 = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"TrackChi2", m_pTrackChi2));

	m_pTrackLength = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"TrackLength", m_pTrackLength));

	m_pClusterSize = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ClusterSize", m_pClusterSize));

	m_pThetaTrack = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ThetaTrack", m_pThetaTrack));

	m_pPhiTrack = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"PhiTrack", m_pPhiTrack));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::processEvent(EVENT::LCEvent *pLCEvent)
{
	LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Processing physics event no " << pLCEvent->getEventNumber() );

	try
	{
		std::vector<caloobject::CaloHit*> caloHitList;
		std::map<unsigned int, std::vector<caloobject::CaloHit*> > caloHitMap;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Creating wrapper hits");

		try
		{
			EVENT::LCCollection *pECalCollection = pLCEvent->getCollection(m_ecalCollectionName);
			this->createCaloHits(pECalCollection, 0, caloHitList, caloHitMap);
		}
		catch(EVENT::DataNotAvailableException &exception)
		{
			LOG4CXX_WARN( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
		}

		try
		{
			EVENT::LCCollection *pHCalCollection = pLCEvent->getCollection(m_ecalCollectionName);
			this->createCaloHits(pHCalCollection, m_nECalLayers, caloHitList, caloHitMap);
		}
		catch(EVENT::DataNotAvailableException &exception)
		{
			LOG4CXX_WARN( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
		}

		// no hit -> no processing
		if(caloHitList.empty())
			return dqm4hep::STATUS_CODE_SUCCESS;

		// algorithms
		algorithm::Cluster clusteringAlgorithm;

		algorithm::ClusteringHelper clusteringHelper;
		algorithm::ClusteringHelperParameterSetting helperSettings;
		clusteringHelper.SetClusteringHelperParameterSetting(helperSettings);

		algorithm::Hough houghTransform;
		algorithm::HoughParameterSetting houghTransformSettings;
		houghTransform.SetHoughParameterSetting(houghTransformSettings);

		algorithm::Tracking trackingAlgorithm;
		algorithm::TrackingParameterSetting trackingParameters;
		trackingAlgorithm.SetTrackingParameterSetting(trackingParameters);


		// contents
		std::vector<caloobject::CaloCluster *> clusters;
		std::vector<caloobject::CaloTrack *>   tracks;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Creating intra layer clusters");

		for(std::map<unsigned int, std::vector<caloobject::CaloHit*> >::iterator iter = caloHitMap.begin(), endIter = caloHitMap.end() ;
				iter != endIter ; ++iter)
			clusteringAlgorithm.Run(iter->second, clusters);

		std::sort(clusters.begin(), clusters.end(), algorithm::ClusteringHelper::SortClusterByLayer);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Filter non - isolated clusters");

		std::vector<caloobject::CaloCluster*> houghClusters;

		for(std::vector<caloobject::CaloCluster*>::iterator iter = clusters.begin(), endIter = clusters.end() ;
				endIter != iter ; ++iter)
			if( ! clusteringHelper.IsIsolatedCluster(*iter, clusters) )
				houghClusters.push_back(*iter);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Processing Hough transform");
		houghTransform.runHough(clusters, tracks, &trackingAlgorithm);

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Analyzing tracks");
		THROW_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, this->analyzeTracks(tracks));

		std::for_each(caloHitList.begin(), caloHitList.end(), [](caloobject::CaloHit *pCaloHit) { delete pCaloHit; });
		std::for_each(clusters.begin(), clusters.end(), [](caloobject::CaloCluster *pCluster) { delete pCluster; });
		std::for_each(tracks.begin(), tracks.end(), [](caloobject::CaloTrack *pTrack) { delete pTrack; });
	}
	catch(EVENT::DataNotAvailableException &exception)
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "Caught EVENT::DataNotAvailableException : " << exception.what() );
		return dqm4hep::STATUS_CODE_SUCCESS;
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

void HoughTransformModule::createCaloHits(EVENT::LCCollection *pLCCollection, unsigned int layerShift,
		std::vector<caloobject::CaloHit*> &caloHitList, std::map<unsigned int, std::vector<caloobject::CaloHit*> > &caloHitMap)
{
	CLHEP::Hep3Vector globalHitShift(0, 0, 0);
	UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder(pLCCollection);

	for(unsigned int h=0 ; h<pLCCollection->getNumberOfElements() ; h++)
	{
		EVENT::CalorimeterHit *pCaloHit = dynamic_cast<EVENT::CalorimeterHit*>(pLCCollection->getElementAt(h));

		if(NULL == pCaloHit)
			continue;

		int cellID[3];
		cellID[0] = cellIDDecoder(pCaloHit)["I"];
		cellID[1] = cellIDDecoder(pCaloHit)["J"];
		cellID[2] = cellIDDecoder(pCaloHit)["K-1"] + layerShift;

		CLHEP::Hep3Vector positionVector(
				pCaloHit->getPosition()[0],
				pCaloHit->getPosition()[1],
				pCaloHit->getPosition()[2]);

		caloobject::CaloHit *pWrapperHit = new caloobject::CaloHit(
				cellID,
				positionVector,
				pCaloHit->getEnergy(),
				pCaloHit->getTime(),
				globalHitShift);

		caloHitMap[ cellID[2] ].push_back(pWrapperHit);
		caloHitList.push_back( pWrapperHit );
	}
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::analyzeTracks( const std::vector<caloobject::CaloTrack*> &tracks )
{
	if( tracks.empty() )
		return dqm4hep::STATUS_CODE_SUCCESS;

	const unsigned int nTracks = tracks.size();

	for(std::vector<caloobject::CaloTrack*>::const_iterator iter = tracks.begin(), endIter = tracks.end() ;
			endIter != iter ; ++iter)
	{
		caloobject::CaloTrack *pTrack = *iter;

		const std::vector<caloobject::CaloCluster*> &trackClusters(pTrack->getClusters());
		const unsigned int nClusters(trackClusters.size());

		const int startingLayer(pTrack->getTrackStartingCluster()->getLayerID());
		const int endingLayer(pTrack->getTrackLastCluster()->getLayerID());
		const int trackLenght(endingLayer - startingLayer);

		const float chi2(pTrack->getChi2());

		float meanClusterSize(0.f);

		std::for_each(trackClusters.begin(), trackClusters.end(),
				[&] (caloobject::CaloCluster *pCluster) {
			meanClusterSize += static_cast<float>(pCluster->getHits().size());
		});

		meanClusterSize /= static_cast<float>(nClusters);

		const float *trackParameters = pTrack->getTrackParameters();

		const CLHEP::Hep3Vector trackPoint1( -1, 0, trackParameters[0] );
		const CLHEP::Hep3Vector trackPoint2( 0, -1, trackParameters[3] );
		const CLHEP::Hep3Vector trackDirection( trackPoint1.cross(trackPoint2).unit() );

		const float theta(trackDirection.theta());
		const float phi(trackDirection.phi());

		// fill monitor elements !
		m_pTrackLength->get<TH1>()->Fill(trackLenght);
		m_pTrackChi2->get<TH1>()->Fill(chi2);
		m_pClusterSize->get<TH1>()->Fill(meanClusterSize);
		m_pThetaTrack->get<TH1>()->Fill(theta);
		m_pPhiTrack->get<TH1>()->Fill(phi);
	}

	m_pNRecTracks->get<TH1>()->Fill(nTracks);

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::startOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::startOfRun(dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endOfRun(dqm4hep::DQMRun *const /*pRun*/)
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode HoughTransformModule::endModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

} 

