/*
 *
 * SlowControlModule.cc source template automatically generated by a class generator
 * Creation date : mar. mars 8 2016
 *
 * This file is part of DQMSDHCAL libraries.
 * 
 * DQMSDHCAL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQMSDHCAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQMSDHCAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "SlowControlModule.h"

// -- dqm4hep headers
#include "dqm4hep/DQMModuleApi.h"
#include "dqm4hep/DQMMonitorElement.h"
#include "dqm4hep/DQMXmlHelper.h"
#include "dqm4hep/DQMPlugin.h"
#include "dqm4hep/DQMCoreTool.h"

// -- dim headers
#include "dic.hxx"

// -- root headers
#include "TGraph.h"

namespace dqm_sdhcal
{

DQM_PLUGIN_DECL( SlowControlModule , "SlowControlModule" )

//-------------------------------------------------------------------------------------------------

CurrentQualityTest::CurrentQualityTest(const std::string &name) :
	DQMQualityTest(name)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::readSettings(const dqm4hep::TiXmlHandle xmlHandle)
{
	m_maxAllowedCurrent = -6;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"MaxAllowedCurrent", m_maxAllowedCurrent));

	m_maxDangerousCurrent = -10;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"MaxDangerousCurrent", m_maxDangerousCurrent));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::init()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode CurrentQualityTest::run(dqm4hep::DQMMonitorElement *pMonitorElement)
{
	const float currentCategory(static_cast<float>(m_maxAllowedCurrent) / 2.f);

	TGraph *pCurrentGraph = pMonitorElement->get<TGraph>();

	if(pCurrentGraph->GetN() == 0)
	{
		m_isSuccessful = false;
		m_message = "No points for current quality check !";
		m_quality = dqm4hep::NO_QUALITY;

		return dqm4hep::STATUS_CODE_SUCCESS;
	}

	float current = pCurrentGraph->GetY()[pCurrentGraph->GetN()-1];

	if(current > currentCategory)
	{
		m_message = "Very good current (${limit} < I µA)";
		dqm4hep::DQM4HEP::replace(m_message, "limit", currentCategory);
		m_quality = dqm4hep::VERY_GOOD_QUALITY;
	}
	else if(current > 2.f*currentCategory)
	{
		m_message = "Rather good current (${lLimit} < I < ${uLimit} µA)";
		dqm4hep::DQM4HEP::replace(m_message, "lLimit", 2.f*currentCategory);
		dqm4hep::DQM4HEP::replace(m_message, "uLimit", currentCategory);
		m_quality = dqm4hep::GOOD_QUALITY;
	}
	else if(current > m_maxDangerousCurrent)
	{
		m_message = "Bad current !! Check it now !!! (${lLimit} < I < ${uLimit} µA)";
		dqm4hep::DQM4HEP::replace(m_message, "lLimit", m_maxDangerousCurrent);
		dqm4hep::DQM4HEP::replace(m_message, "uLimit", m_maxAllowedCurrent);
		m_quality = dqm4hep::BAD_QUALITY;
	}
	else
	{
		m_message = "SIR ! SIR ! ON EN A GROS !! (I < ${uLimit} µA)";
		dqm4hep::DQM4HEP::replace(m_message, "uLimit", m_maxDangerousCurrent);
		m_quality = dqm4hep::VERY_BAD_QUALITY;
	}

	m_isSuccessful = true;

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

bool CurrentQualityTest::canRun(dqm4hep::DQMMonitorElement *pMonitorElement) const
{
	return (pMonitorElement->get<TGraph>() != 0);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

SlowControlModule::SlowControlModule() :
		dqm4hep::DQMStandaloneModule()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

SlowControlModule::~SlowControlModule()
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::readSettings( const dqm4hep::TiXmlHandle xmlHandle )
{
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::registerQualityTestFactory(this,
			"CurrentQualityTest", new CurrentQualityTest::Factory()));

	m_startTime = time(0);

	// settings
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"LVInfo", m_lvInfoName));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"HVInfo", m_hvInfoName));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"TemperatureInfo", m_temperatureInfoName));

	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"PressureInfo", m_pressureInfoName));

	m_globalDynamicGraphRange = 60*60;   // default is 1h
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::readParameterValue(xmlHandle,
			"GlobalDynamicGraphRange", m_globalDynamicGraphRange));


	// monitor elements
	m_pGlobalTemperatureElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"GlobalTemperature", m_pGlobalTemperatureElement));

	m_pGlobalPressureElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"GlobalPressure", m_pGlobalPressureElement));

	m_pHighVoltageVSetElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"VSet", m_pHighVoltageVSetElement));

	m_pHighVoltageVReadElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"VRead", m_pHighVoltageVReadElement));

	m_pHighVoltageVSetReadDiffElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"VSetVReadDiff", m_pHighVoltageVSetReadDiffElement));

	m_pHighVoltageISetElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ISet", m_pHighVoltageISetElement));

	m_pHighVoltageIReadElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"IRead", m_pHighVoltageIReadElement));

	m_pHighVoltageISetReadDiffElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"ISetIReadDiff", m_pHighVoltageISetReadDiffElement));

	m_pLowVoltageElement = NULL;
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
			"LowVoltage", m_pLowVoltageElement));

	this->configureGraph( m_pGlobalTemperatureElement->get<TGraph>() );
	m_pGlobalTemperatureElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);
	m_pGlobalTemperatureElement->setDescription("Global temperature graph from a device near (outside probe) the SDHCAL detector. \n"
			"X axis is time in seconds from the module start time ( t0 = " + dqm4hep::DQM4HEP::typeToString(m_startTime) + ")");

	this->configureGraph( m_pGlobalPressureElement->get<TGraph>() );
	m_pGlobalPressureElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);
	m_pGlobalPressureElement->setDescription("Global pressure graph from a device near (outside probe) the SDHCAL detector. \n"
			"X axis is time in seconds from the module start time ( t0 = " + dqm4hep::DQM4HEP::typeToString(m_startTime) + ")");

	this->configureGraph( m_pHighVoltageVSetElement->get<TGraph>() );
	this->configureGraph( m_pHighVoltageVReadElement->get<TGraph>() );
	this->configureGraph( m_pHighVoltageVSetReadDiffElement->get<TGraph>() );
	this->configureGraph( m_pHighVoltageISetElement->get<TGraph>() );
	this->configureGraph( m_pHighVoltageIReadElement->get<TGraph>() );
	this->configureGraph( m_pHighVoltageISetReadDiffElement->get<TGraph>() );


	// book HV plot per chamber using current dim info
	DimBrowser browser;
	int nServices = browser.getServices( (char *) m_hvInfoName.c_str() );

	if( 0 != nServices )
	{
		char *pServiceName, *pFormat;
		int serviceType;

		while(1)
		{
			serviceType = browser.getNextService(pServiceName, pFormat);

			if( 0 == serviceType )
				break;

			// looking for service. No command, no rpc
			if( DimSERVICE != serviceType )
				continue;

			DimCurrentInfo hvDimInfo( pServiceName , (void *) NULL , 0 );
			HVInfo *pDimHVInfo = (HVInfo *) hvDimInfo.getData();
			int dimDataSize = hvDimInfo.getSize();

			if( 0 == pDimHVInfo || 0 == dimDataSize )
				continue;

			if( pDimHVInfo->m_chamberID < 0 )
				continue;

			unsigned int chamberID = pDimHVInfo->m_chamberID;

			if( m_chamberHVElementMap.find( chamberID ) != m_chamberHVElementMap.end() )
				continue;

			LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Booking HV graph for chamber id = " << chamberID );

			dqm4hep::DQMMonitorElementPtr monitorElement;
			RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
					"VReadPerLayer", chamberID, monitorElement));

			this->configureGraph( monitorElement->get<TGraph>() );
			monitorElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);

			m_chamberHVElementMap[ chamberID ] = monitorElement;

            monitorElement = 0;
            RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::bookMonitorElement(this, xmlHandle,
                            "IReadPerLayer", chamberID, monitorElement));

            this->configureGraph( monitorElement->get<TGraph>() );
            monitorElement->get<dqm4hep::TDynamicGraph>()->SetRangeLength(m_globalDynamicGraphRange);

            m_chamberCurrentElementMap[ chamberID ] = monitorElement;

            RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMXmlHelper::createQualityTest(this, xmlHandle,
        			"CurrentCheckQuality"));

        	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::addQualityTest(this,
        			monitorElement, "CurrentCheckQuality"));
		}
	}


	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::initModule()
{
	// scan dns and find hv service list
	LOG4CXX_INFO( dqm4hep::dqmMainLogger , "Scanning Dns for HV services" );

	DimBrowser browser;
	int nServices = browser.getServices( (char *) m_hvInfoName.c_str() );

	if( 0 == nServices )
	{
		LOG4CXX_ERROR( dqm4hep::dqmMainLogger , "No HV service found for input service name '" << m_hvInfoName << "'" );
		return dqm4hep::STATUS_CODE_NOT_FOUND;
	}

	char *pServiceName, *pFormat;
	int serviceType;

	while(1)
	{
		serviceType = browser.getNextService(pServiceName, pFormat);

		if( 0 == serviceType )
			break;

		// looking for service. No command, no rpc
		if( DimSERVICE != serviceType )
			continue;

		LOG4CXX_DEBUG( dqm4hep::dqmMainLogger , "Found HV service : " << pServiceName << " , format : " << pFormat );

		m_hvInfoServiceNames.push_back( pServiceName );
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::startOfCycle()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::process()
{
	std::string currentTimeStr;
	time_t currentTime = time(0);
	dqm4hep::DQMCoreTool::timeToHMS(currentTime, currentTimeStr);

	// get and fill temperature and pressure
	float temperature = this->getGlobalTemperature();
	m_pGlobalTemperatureElement->setTitle( "Global temperature (" + currentTimeStr + ")" );
	m_pGlobalTemperatureElement->get<dqm4hep::TDynamicGraph>()->AddPoint( currentTime - m_startTime , temperature );

	float pressure = this->getGlobalPressure();
	m_pGlobalPressureElement->setTitle( "Global pressure (" + currentTimeStr + ")" );
	m_pGlobalPressureElement->get<dqm4hep::TDynamicGraph>()->AddPoint( currentTime - m_startTime , pressure );

	// get lv info
	LVInfo lvInfo;
	this->getLowVoltageInfo( lvInfo );

	std::stringstream lvText;
	lvText << "Low voltage : "
			<< lvInfo.m_vSet << " V (set) / "
			<< lvInfo.m_vRead << " V (read) / "
			<< lvInfo.m_iRead << " A (read)";

	m_pLowVoltageElement->get<dqm4hep::TScalarString>()->Set( lvText.str() );
	m_pLowVoltageElement->setTitle( "Low voltage (" + currentTimeStr + ")" );


	// get hv info for each chamber
	HVInfoMap hvInfoMap;
	this->getHighVoltageInfos( hvInfoMap );

	if( ! hvInfoMap.empty() )
	{
		// reset TGraphs
		m_pHighVoltageVSetElement->get<TGraph>()->Set(0);
		m_pHighVoltageVReadElement->get<TGraph>()->Set(0);
		m_pHighVoltageVSetReadDiffElement->get<TGraph>()->Set(0);
		m_pHighVoltageISetElement->get<TGraph>()->Set(0);
		m_pHighVoltageIReadElement->get<TGraph>()->Set(0);
		m_pHighVoltageISetReadDiffElement->get<TGraph>()->Set(0);

		int pointID = 0;

		for(HVInfoMap::iterator iter = hvInfoMap.begin(), endIter = hvInfoMap.end() ;
				endIter != iter ; ++iter)
		{
			m_pHighVoltageVSetElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_vSet );
			m_pHighVoltageVSetElement->setTitle( "High voltage (VSet) [" + currentTimeStr + "]" );

			m_pHighVoltageVReadElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_vRead );
			m_pHighVoltageVReadElement->setTitle( "High voltage (VRead) [" + currentTimeStr + "]" );

			m_pHighVoltageVSetReadDiffElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_vSet - iter->second.m_vRead );
			m_pHighVoltageVSetReadDiffElement->setTitle( "High voltage (VSet - VRead) [" + currentTimeStr + "]" );


			m_pHighVoltageISetElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_iSet );
			m_pHighVoltageISetElement->setTitle( "High voltage (ISet) [" + currentTimeStr + "]" );

			m_pHighVoltageIReadElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_iRead );
			m_pHighVoltageIReadElement->setTitle( "High voltage (IRead) [" + currentTimeStr + "]" );

			m_pHighVoltageISetReadDiffElement->get<TGraph>()->SetPoint( pointID , iter->first , iter->second.m_iSet - iter->second.m_iRead );
			m_pHighVoltageISetReadDiffElement->setTitle( "High voltage (ISet - IRead) [" + currentTimeStr + "]" );

			DQMMonitorElementIDMap::iterator hvChIter = m_chamberHVElementMap.find( iter->first );

			if( hvChIter != m_chamberHVElementMap.end() )
			{
				hvChIter->second->get<dqm4hep::TDynamicGraph>()->AddPoint( currentTime - m_startTime , iter->second.m_vRead );
				hvChIter->second->setTitle( "High voltage (VSet). Chamber id " + dqm4hep::DQM4HEP::typeToString(iter->first) + ". [" + currentTimeStr + "]" );
			}

            DQMMonitorElementIDMap::iterator iChIter = m_chamberCurrentElementMap.find( iter->first );

            if( iChIter != m_chamberCurrentElementMap.end() )
            {
                    iChIter->second->get<dqm4hep::TDynamicGraph>()->AddPoint( currentTime - m_startTime , iter->second.m_iRead );
                    iChIter->second->setTitle( "Current (IRead). Chamber id " + dqm4hep::DQM4HEP::typeToString(iter->first) + ". [" + currentTimeStr + "]" );
            }

			pointID++;
		}
	}

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::endOfCycle()
{
	// run all quality tests on all monitor elements
	RETURN_RESULT_IF(dqm4hep::STATUS_CODE_SUCCESS, !=, dqm4hep::DQMModuleApi::runQualityTests(this));

	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

dqm4hep::StatusCode SlowControlModule::endModule()
{
	return dqm4hep::STATUS_CODE_SUCCESS;
}

//-------------------------------------------------------------------------------------------------

float SlowControlModule::getGlobalTemperature()
{
	DimCurrentInfo temperatureInfo( (char *) m_temperatureInfoName.c_str() , 0.f );
	return temperatureInfo.getFloat();
}

//-------------------------------------------------------------------------------------------------

float SlowControlModule::getGlobalPressure()
{
	DimCurrentInfo pressureInfo( (char *) m_pressureInfoName.c_str() , 0.f );
	return pressureInfo.getFloat();
}

//-------------------------------------------------------------------------------------------------

void SlowControlModule::getHighVoltageInfos( HVInfoMap &hvInfoMap )
{
	hvInfoMap.clear();

	for(dqm4hep::StringVector::const_iterator iter = m_hvInfoServiceNames.begin(), endIter = m_hvInfoServiceNames.end() ;
			endIter != iter ; ++iter)
	{
		std::string serviceName = *iter;

		// get chamber hv info
		DimCurrentInfo hvDimInfo( (char *) serviceName.c_str() , (void *) NULL , 0 );
		HVInfo *pDimHVInfo = (HVInfo *) hvDimInfo.getData();
		int dimDataSize = hvDimInfo.getSize();

		if( 0 == pDimHVInfo || 0 == dimDataSize )
			continue;

		if( pDimHVInfo->m_chamberID < 0 )
			continue;

		hvInfoMap[ pDimHVInfo->m_chamberID ] = *pDimHVInfo;
	}
}

//-------------------------------------------------------------------------------------------------

void SlowControlModule::getLowVoltageInfo( LVInfo &lvInfo )
{
	// initialize to zero for security
	lvInfo.m_vSet = 0.f;
	lvInfo.m_vRead = 0.f;
	lvInfo.m_iRead = 0.f;

	DimCurrentInfo lvDimInfo( (char *) m_pressureInfoName.c_str() , (void *) NULL , 0 );
	LVInfo *pDimLVInfo = (LVInfo *) lvDimInfo.getData();
	int dimDataSize = lvDimInfo.getSize();

	if( 0 == pDimLVInfo || 0 == dimDataSize )
		return;

	// get copy
	lvInfo = *pDimLVInfo;
}

//-------------------------------------------------------------------------------------------------

void SlowControlModule::configureGraph( TGraph *pGraph )
{
	if( ! pGraph )
		return;

	pGraph->SetMarkerStyle(23);
	pGraph->SetMarkerSize(1);
	pGraph->SetMarkerColor(kBlack);
}

} 

